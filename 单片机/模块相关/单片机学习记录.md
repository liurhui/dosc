### 数码管

```c
u8 tableA[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,
  0x77,0x7C,0x39,0x5E,0x79,0x71};
//共阴数码管段码0至F
u8 tableB[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,
  0x88,0x83,0xC6,0xA1,0x86,0x8E};
//共阳数码管段码0至F
```

![共阴共阳8段码](共阴共阳8段码.png)

#### 4位数码管

```c
uchar code table_duan[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,
  0x88,0x83,0xC6,0xA1,0x86,0x8E};
uchar code table_wei[]={0xfe,0xfd,0xfb,0xf7};
//共阳数码管段码0至F
fe  1111 1110
fd	1111 1101
fb	1111 1011
f7	1111 0111
//用于 千百十个 每个位显示合成一位数   
// wei 接到74HC138     duan   接到74HC573
```

![4位数码管](4位数码管.jpg)

### 点阵
##### 8行和8列点阵
	ROW1-8、COL1-8分别控制行和列的1-8led。ROWx高电平、COLy低电平，对应的第x行、第y列led灯亮。
```plaintext
//这里以 1为例
ROW-0x01  COL-0xef 
ROW-0x02  COL-0xe7
ROW-0x04  COL-0xef
ROW-0x08  COL-0xef
ROW-0x10  COL-0xef
ROW-0x20  COL-0xef
ROW-0x40  COL-0xef
ROW-0x80  COL-0xc7
/*
 * bit都从右往左   0亮共阴、1亮共阳
 * ef ->1111 0111   
 * e7 ->1110 0111      
 */
```
###### 工作原理：
	通常以：公共端为行。
	共阳：每行八个正极，接在一起，使得一行公共去控制八列。共阴以此类推。
###### 测试引脚：
	共阳：行为高电平，列为低电平，亮。     
	共阴：行为低电平，列为高电平，亮。
	通常字正朝上对自己,左脚第一脚为1pin。   	
###### 实物图中：
	点阵对应的 引脚不是顺序 的,使用万用表去测,先找一个点以一个方向开始找出行，或者列。如果是行把其余的列全测出来，再测其余行。
	用笔画一个矩阵的样子，引出16个引脚对应着标记看led的灯。
###### 编写代码：    
	看作行是分开的，列是一起的。我们去使用8行，控制所有的点。反之列是分开的，行去控制所有点。 
	通常循环行，给每个列的点赋值。速度够快就感觉是同时亮。
```c
unsigned char code tab[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f}; // 0-7行
unsigned char code graph[11][8]={显示的内容8行8列的十六进制};
    //11：我要显示11个字。  
    //8：显示的宽度为8也就8个十六进制。
//[1][0]-[1][8] 为一个字,一直到[11][0]-[11][8]。11个字全部 ****
```
![点阵1](点阵1.jpg)

##### ARK点阵
![点阵型号表](点阵型号表.jpg)

##### 4块点阵
	需要使用 74HC138 和74Hc595
```plaintext
	一、138 是3个输入8个输出实现 3入选1出
	二、595 是串入并出带有锁存功能移位寄存器
	正常使用时SCLR为高电平， G为低电平。
	从SER每输入一位数据，串行输入时钟SCK上升沿有效一次，直到八位数据输入完毕，输出时钟上升沿有效一次，此时，输入的数据就被送到了输出端。
```
![4块点阵接线](4块点阵接线.jpg)

##### 74hc595使用说明
```plaintext
74hc595外形图
    _______
QB--|1   16|--Vcc
QC--|2   15|--QA
QD--|3   14|--SI
QE--|4   13|--/G
QF--|5   12|--RCK
QG--|6   11|--SCK
QH--|7   10|--/SCLR
GND-|8    9|--QH'
    |______|
 
74595的数据端：
QA--QH: 八位并行输出端，可以直接控制数码管的8个段。
QH': 级联输出端。将它接下一个595的SI端。
SI: 串行数据输入端。
 
74595的控制端说明：
	/SCLR(10脚): 低点平时将移位寄存器的数据清零。通常我将它接Vcc。

	SCK(11脚)：上升沿时数据寄存器的数据移位。QA-->QB-->QC-->...-->QH；下降沿移位寄存器数据不变。（脉冲宽度：5V时，大于几十纳秒就行了。我通常都选微秒级）

	RCK(12脚)：上升沿时移位寄存器的数据进入数据存储寄存器，下降沿时存储寄存器数据不变。通常我将RCK置为低点平，当移位结束后，在RCK端产生一个正脉冲（5V时，大于几十纳秒就行了。我通常都选微秒级），更新显示数据。
	
	/G(13脚): 高电平时禁止输出（高阻态）。如果单片机的引脚不紧张，用一个引脚控制它，可以方便地产生闪烁和熄灭效果。比通过数据端移位控制要省时省力。 
```
###### 74hc595使用注意事项
```plaintext
	1、74164和74595功能相仿，都是8位串行输入转并行输出移位寄存器。74164的驱动电流(25mA)比74595(35mA)的要小,14脚封装，体积也小一些。
	
	2、74595的主要优点是具有数据存储寄存器，在移位的过程中，输出端的数据可以保持不变。这在串行速度慢的场合很有用处，数码管没有闪烁感。
	
	3、595是串入并出带有锁存功能移位寄存器，它的使用方法很简单，在正常使用时SCLR为高电平， G为低电平。
	从SER每输入一位数据，串行输595是串入并出带有锁存功能移位寄存器，它的使用方法很简单，如下面的真值表，在正常使用时SCLR为高电平， G为低电平。
	从SER每输入一位数据，串行输入时钟SCK上升沿有效一次，直到八位数据输入完毕，输出时钟上升沿有效一次，此时，输入的数据就被送到了输出端。
```
###### 74hc595代码思路
```plaintext
595具体使用的步骤:
第一步：
	目的：将要准备输入的位数据移入74HC595数据输入端上。
	方法：送位数据到_595。
第二步：
	目的：将位数据逐位移入74HC595，即数据串入
	方法：SCK_595产生一上升沿，将PSI_595上的数据移入74HC595中.从低到高
第三步：
	目的：并行输出数据。即数据并出
	方法：P1.1产生一上升沿，将由SI_595上已移入数据寄存器中的数据送入到输出锁存器。 

说明： 
	从上可分析：从SCK_595产生一上升沿（移入数据）和RCK_595产生一上升沿（输出数据）是二个独立过程，实际应用时互不干扰。即可输出数据的 同时移入数据。
程序如下，复制就能用。
```
###### 74hc595参考代码
```c
sbit SI_595=P2^0;
sbit RCK_595=P2^2;
sbit SCK_595=P2^1;
void HC595SendData(unsigned char SendVal)//发送数据
{  
  unsigned char i;
  for(i=0;i<8;i++) 
   {
if((SendVal<<i)&0x80) SI_595=1;
else SI_595=0;
SCK_595=0;//从SCK_595产生一上升沿(移入数据)
_nop_();
_nop_();
SCK_595=1; 
   }
} 
void HC595ShowData()//RCK_595产生一上升沿(输出数据)
{
  RCK_595=0;
  _nop_();
  _nop_();
  RCK_595=1; 
} 
```
![矩阵原理图](矩阵原理图.jpg)

```c
源程序
#include <reg52.h> 
#include <intrins.h>
unsigned char code NUM[8]={0x00,0x00,0xe00,0x82,0xff,0x80,0x00,0x00};
#define ROW P3 
sbit SI=P2^0;
sbit RCK=P2^2;
sbit SCK=P2^1; 
void HC595SendData(unsigned char SendVal)
{  
  unsigned char i;
 
  for(i=0;i<8;i++) 
   {
if((SendVal<<i)&0x80) SI=1;
else SI=0;
 
SCK=0;
_nop_();
_nop_();
SCK=1; 
   }
} 
void HC595ShowData()
{
  RCK=0;
  _nop_();
  _nop_();
  RCK=1; 
}
 
void main(void)
{
  unsigned char i;
  while(1)
  {
     for(i=0;i<8;i++)
{ 
  HC595SendData(NUM[i]);
  ROW=0x00;
  HC595ShowData();
  ROW=i|0x80;
}
  }
}
```

**双色**

![双色点阵](双色点阵.png)

