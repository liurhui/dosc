
---
创建日期:
  -  2022/11/14
---
## 搭建环境
#### 版本说明
	AiThinkerIDE_V0.5  配置环境能用
	AiThinkerIDE_V1.0  忽略配置太过繁杂
	AiThinkerIDE_V1.5  可以以替代0.5和1.0  比较好用推荐
	区别：后面的带有自带添加环境变量。
##### 0.5配置环境变量
	自己创建 Espressif\IDE  把两个都放进去 然后去加环境变量
	编辑环境变量选：系统变量 -> Path 新增 
	`C:\Espressif\IDE\AiThinkerIDE_V0.5\cygwin\bin`
	`C:\Espressif\IDE\xtensa-lx106-elf\bin`
##### 1.5配置环境变量
	直接参考安信可官方的文章（亲测可用）
	https://blog.csdn.net/Boantong_/article/details/106229281

#### 软件下载说明   qq群号 :434878850  (AI-物联网全栈开发之旅)
	1、eclipes 其实下载了没有用，IDE已经自带了。估计是0.5版本需要。
	2、编译链工具，主要是linux平台要用所以要整理，win的在IDE里基本都给了压缩包。
	3、官方给的文件很散，还没网友整理的整齐。
	4、半颗心脏的教程图不对文（很难参照），但是基本上流程是对的。所以不一定得按半颗心脏的文档去操作，可以看下别的网友的。
	5、编译链文件是需要去配环境变量的，所以得手动根据版本进行替换bin路径。

	1、eclipes for c/c++ 2019版本： 公众号 徐宏blog(半颗心脏)
	https://pan.baidu.com/s/1Eqg0nu_fHSIVTwiFvLLijA 提取码：fqt7 
	压缩包解压后是免安装的，配个项目存储位置后，根据文档去配置依赖。
	
	2、AThinkerIDE集合包 （b站网友提供的）
	视频： https://www.bilibili.com/read/cv7760529/
	https://pan.baidu.com/s/1Fu1Fen68SPfp0qzLvoxRRg 提取码: nsmn
	配置：https://docs.ai-thinker.com/ai_ide_install?s[]=aithinkeride

	3、cywin window： 都在 AThinkerIDE 包里或安装IDE后自带
	安装后自带的需要在项目内配置下路径。
	
	4、2.0和3.0SDK 官方下载地址  包含了AThinkerIDE0.5版本的编译链
	https://github.com/espressif/ESP8266_RTOS_SDK
	AThinkerIDE0.5版本的编译链下载（点击立即下载）
	https://dl.espressif.com/dl/xtensa-lx106-elf-win32-1.22.0-88-gde0bdc1-4.8.5.tar.gz

#### 安信可 开发工具手册集合（Ai-ThinkerIDE_V1.5）
https://docs.ai-thinker.com/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B72
##### aithinker_serial_tool（串口调试工具 波特率选 74880）
https://docs.ai-thinker.com/_media/tools/aithinker_serial_tool_v1.2.3.7z
##### flash_download_tool（烧录工具）
https://docs.ai-thinker.com/_media/flash_download_tool_v3.8.5_1.zip
参照blog
https://blog.csdn.net/qq_26043945/article/details/124623326

**备忘：**
	如果出现无法烧写  GPIO0 先通过接地一会放电后 然后板子上电（灯会闪烁一下），再点击开始下载 。至于com 口先上一次电记录下。
	黑色的板要插电池，白色的不用。原因未知，这里利用了水墨屏的PCB刚好有8266的外围基础电路。所以可以省去买8266开发板。
	
**烧录bin根据SDK版本编译后生成两种烧录方式：**
	1、带boot.bin的  2、不带boot.bin的
	3、0x3fe000、0x3fc000、0x00000  地址基本固定，剩余一个地址基本得看编译后 编辑器IDE面板的显示。
**编译后生成bin示例**
```plaintext
!!!
Support boot_v1.4 and +
Generate user1.4096.new.6.bin successully in folder bin/upgrade.
boot.bin------------>0x00000
user1.4096.new.6.bin--->0x01000
!!!
make[1]: Leaving directory '/cygdrive/c/Users/81839/Desktop/github/StudyInEsp8266/3_TimerLED/app'
```
**不带boot.bin**
烧录文件     烧录地址
blank.bin        0x3fe000
esp_init_data_default.bin        0x3fc000
eagle.flash.bin        0x00000
eagle.irom0text.bin         0x40000

**带boot.bin**
烧录文件   烧录地址
blank.bin    0x3fe000
esp_init_data_default.bin   0x3fc000
boot.bin    0x00000
user1.4096.new.6.bin    0x01000

**下载器选值（8266-12F举例）**
	32Mbit，也就是4M flash ,所以地址分别是 0x3FC000 和 0x3FE000 , 最后2个的烧录文件地址看编译之后结果而决定！
	四根线选`QIO`，六根线选`DIO`，至于`QOUT`和`DOUT`和`flash`芯片有关，平时最多的是`DIO`或者是`QIO`！
	
	https://blog.csdn.net/wowocpp/article/details/81368635  可以看下flash
	
![[ESP8266下载器.PNG]]
![[ESP8266下载器下载完成.PNG]]

### IDE问题集
#### 当make clean 时一直报Error: Cannot run program "make": xxxxx  出现PATH:{xxxxxxxx;xxxxxx;xxx}把你的环境变量的内容都打印出来。
```plaintext
缘由：
	记录一下，当正常使用中把1.5 改回1后又改回1.5 。
	
经过实验：
	一直以为是环境变量没改对。但是发现怎么改都无效。最后 把 IDE 存储的工作组文件夹eclipse-workspace 给全删了。发现正常了。
	
总结原因：
	注意是因为把IDE 提示的是否打开改工作区的提示框禁掉了。导致重装时候也不会提示需要把工作区删了。再从C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse 打开eclipse.exe  桌面的那个exe 一般还是从原本的工作区进入，是个bug即使删除了原本的工作区他还会重新生成莫明奇妙。
	
```
#### 当程序没问题前提下，Cygwin GCC 方式导入 build时报什么xtensa-lx106-elf 类似这样的内容的错误，只会是你没有配置Environment 的  CYGWIN_HOME 的value 即 cygwin的路径
```plaintext
总结原因:
	cygwin在你所安装的IDE的目录下如：
		C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cygwin
```
#### Makefile 错误即环境变量问题，编译链替换：
```plaintext
https://blog.csdn.net/m0_50458807/article/details/114915004
```
#### 添加快捷键配置环境和下载程序
```plaintext
https://blog.csdn.net/weixin_39676479/article/details/119882794?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119882794-blog-77985541.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119882794-blog-77985541.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1
```
## 实践篇
IDE 路径`C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse\eclipse.exe`
### Ai-ThinkerIDE_V1.5 编译 3.0/2.1.x/2.2.x  SDK版本
	1、图文教程
	https://aithinker.blog.csdn.net/article/details/106229281   
	2、B友视频示例（没啥好看的操作贼拉跨速度极慢，当失败太多怀疑人生时候看下怎么操作。）
	https://www.bilibili.com/video/av714622779/?vd_source=8c250cc458d476b5cdce2e6ed0343a02
	3、当bulid时，报 xtensa-lx106-elf-gcc 错误时
		就是esp8266 的环境变量配成了v5.2.0_for_3.0\xtensa-lx106-elf\bin 。 

```plaintext
环境变量只要这4个 其余的得删掉
esp8266 是v5.2.0_for_3.0\bin 。 esp32是xtensa-esp32-elf-5.0\bin 。

	
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\mingw32\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp32\xtensa-esp32-elf-5.0\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp8266\v5.2.0_for_3.0\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\usr\bin
 
```
#### 准备工作
	不需要什么准备。
#### 导入时工作 
	1、导入项目 选择 File→Import ，下面步骤：
	2、点开C/C++分支，并选中Existing Code as Makefile Project：
	3、取消C++的勾选，选中 Cross Gcc，点击Browser，选中我们解压后所在的目录。点击finish。

#### 导入后工作（make 以ESP-12F为例）
	1、Properties --> C/C++ Build --> Build command 中添加编译规则 make COMPILE=gcc BOOT=new APP=1 SPI_SPEED=40 SPI_MODE=DIO SPI_SIZE_MAP=6
	2、在Properties --> C/C++ Build --> Build directory 选择编译的工程路径，比如根目录下的 IoT_Demo工程。
	3、 先Clean Project ，后Build Project 。如果Build Project是灰色的，点击一下代码窗口空白处，就不会灰的了。很可能是你之前build运行了其他项目。这样反正我是成功了。

#### 示例项目
	git clone https://gitee.com/xuhongv/ESP8266_NONOS_SDK
	1.手动删除根目录下的`driver_lib`和 `third_party`这2个文件夹;
	2.把 `ESP8266_NONOS_SDK\examples` 内的 `IoT_Demo` 复制到 `ESP8266_NONOS_SDK`
	3.然后再进行 导入。 



### Ai-ThinkerIDE_V1.5 编译 2.0 SDK
	1、图文教程
	https://blog.csdn.net/weixin_56657463/article/details/124778792
	https://aithinker.blog.csdn.net/article/details/106229281
	2、当bulid时，报 xtensa-lx106-elf-gcc 错误时，就是IDE的Environment没配置 cygwin 路径。
```plaintext
环境变量只要这3个 其余的得删掉
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\usr\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cywin\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp8266\v4.8.2_for_2.0\bin
```
#### 准备工作
	随Ai-ThinkerIDE_V1.5一起的两个依赖文件。v4.8.2_for_2.0.zip 和 plugin_cygwin.zip
	根据环境变量看出 放到Ai-ThinkerIDE_V1.5相对的文件内。
#### 导入时工作
	1、导入项目 选择 File→Import ，下面步骤：
	2、点开C/C++分支，并选中Existing Code as Makefile Project：
	3、取消C++的勾选，选中 Cygwin GCC，点击Browser，选中我们解压后所在的目录。点击finish。

#### 导入后工作
	1、make COMPILE=gcc BOOT=new APP=1 SPI_SPEED=40 SPI_MODE=DIO SPI_SIZE_MAP=6
	2、查看Environment 的  CYGWIN_HOME  的 value 把  cygwin 路径填入
	 `C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cygwin`然后点apply ，后点确认。 
	3、 先Clean Project ，后Build Project 。如果Build Project是灰色的，点击一下代码窗口空白处，就不会灰的了。很可能是你之前build运行了其他项目。这样反正我是成功了。
	
#### 示例项目 （以半颗心脏的git 2.0的代码示例集合）
	git clone https://github.com/xuhongv/StudyInEsp8266.git
	1. 直接按导入去操作就好，代码没问题的。






---
记录日期:
  -  2022/11/17
---

## 开始学习示例
打开 IDE `C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse\eclipse.exe`

https://blog.csdn.net/xh870189248/article/details/78155357  可以跑电路和代码没问题以2.0SDK 来配置导入项目流程

### 8266-12F
地址范围  `0x000 000 - 0x3ff fff `        每个扇区 `4kb  =1024*4`
扇区范围    `3ff fff /1024/4  = 4 194 303 /1024/4 = 16383  =3ff `
所以扇区范围是  `0x000 - 0x3FF`

### 分为  FOTA支持云端升级，和non-FOTA不支持云端升级
![[ESP8266的bin说明.PNG]]
![[ESP8266的bin说明NON-FOTA.PNG]]
```plaintext
	blank.bin        0x3fb000  // 貌似之前都没弄这个也行
	blank.bin        0x3fe000
	esp_init_data_default_v8.bin        0x3fc000
	eagle.flash.bin        0x00000   // 看编译后的输出显示
	eagle.irom0text.bin         0x10000    // 看编译后的输出显示
	26M   40MHZ   DOUT    32Mbit     1152000
```


### ESP8266-12F 烧录 得按RST 才会读取gpio （没自动下载电路才要）
 先按住 BOOT 再按住RST  再松开RST  再松开BOOT 。下载完再按下RST。
原因是看规格书
因为开发板的GPIO0是 接 BOOT 按钮  ，复位应该是让恢复回默认高
![[ESP8266的开发板bin烧录说明.PNG]]



### 开发指南
	区别 51 就是 不是通过 while(1)  用中断去触发具体时间去反复执行。
	ESP8266是基于内核回调。
**1、大致主体函数**
	1、应用函数:必须由另一个函数调用才会执行
	2、中断函数:发生硬件中断时会调用这个函数
	3、回调函数:当某系统事件发生时,相点的国调通数由 non-OS SDK内核调用执行
	4、任务函数:系统空闲的时候执行
	2、3、4 CPU通过发送的令内部去处理(正因如此,所以問单)
```c
void user_init(void) { 
	// 初始化相关的参数和外设等
	// 初始化(需要用到哪些功能就进行相关配置,打开一个开关)
	// 他这里只是预编译后 相当于发送给内核指令， 进入内核处理 。
}

void xxxx_interrupt() { //如果有中断的话进行中断处理
//.....中断处理
}

void xxx_Cb(){//如果有回调通数的话就进入回调两数
//....回调处理
}

void xxx_task(){//如果有任务的话进入任务通数
//....任务处理
}
```

**2、函数名规则**
```plaintext
应用函数前面加 ICACHE_FLASH_ATTR 宏  和IRAM_ATTR宏
 ICACHE_FLASH_ATTR ： 放flash  比 iRAM 慢  但空间大
 IRAM_ATTR： 放 iRAM  速度快， 但空间小
 相当于一个是存储芯片 一个是内存芯片
```

**3、SDK  相当于提供API 可对内核的修改或设置**
```plaintext
	需要的是进行 GPIO口初始化、定时器初始化、中断初始化。
	
	想通过GPIO口电平变化去执行，可以用外部中断触发模式。
	想通过周期性每隔多久去执行，可以用配置定时器。
	
	中断触发是替代普通的GPIO 电平检测API 。更严谨 避免抖动bug
	定时器 是替代普通的自定义 延时函数。 更精准
	
	外部硬件定时器是比软件定时器更加精准，因为软件定时器会受到 代码的机器周期执行时间而影响。

	定时器、GPIO 都是 用中断方式去构思。

	1、 要到的IO口 配置下模式 
	2、中断一般得配置寄存器，然后再中断处理函数内封装些业务逻辑。
	3、尤其是串口中断 配置时用到的 宏 api 寄存器 都比较多，但很简单的。套别人写的模板去改一改就好。主要是思考数据怎么做结构。以及验证数据包是否完整。
```
**4、注意 ESP8266_NONOS_SDK_V1.5.2  - v2.2.1 之间的版本，需要 再user_main.c  手动加函数**
	复制放到 user_main.c  在 init 主函数前面
```c
 void ICACHE_FLASH_ATTR user_rf_pre_init(void){
	 //配置ESP8266的射频参数
	if(!system_partition_table_regist(at_partition_table, sizeof(at_partition_table)/sizeof(at_partition_table[0]),SPI_FLASH_SIZE_MAP)) {
		os_printf("system_partition_table_regist fail\r\n");
		while(1);
	}
 }
 
 void ICACHE_FLASH_ATTR unit32 user_rf_cal_sector_set(void){
	 // 配置ESP8266的校准信息
	enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5;
            break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;
            break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;
            break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;
            break;
        case FLASH_SIZE_32M_MAP_512_512:rf_cal_sec = 1024 - 5;
            break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;
            break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;
            break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5;
            break;
        default:
            rf_cal_sec = 0;
            break;
    }
    return rf_cal_sec;
 }
```
**5、注意 坑**
```plaintext
//像  uint32_t  这些都是在 c_types.h内定义的
//像 sint8_t 、 int8_t 、int8、 sint8 、s8 五种写法都是 signed char 的简写
//像 uint8 、uint8_t 、u8  三种写法都是 unsigned char
//而 
//像 uint32_t  带 t的都是 long    uint32 不带t 是int   注意坑
```

#### 1、GPIO(配套示例GPIO_Input)
**注意：**
	ESP8266-12F 自身的那个小蓝色LED的阴极是接在 GPIO2， 阳极是接VCC 。它受内核管控，即使操作了也会被内核给覆盖亮灭。
##### 基础熟记
	1、两个库 //没有库去官方的SDK内去拷贝来。
	2、设置管脚是普通IO口，还是第二功能IO口。
	3、管脚模式，管脚电平。
```c
//两个库
#include "eagle_soc.h" 
#include  "gpio.h" 

//设置管脚是普通IO口，还是第二功能IO口
/*说明
	参数一表示 引脚， 参数二表示作为普通IO口/第二功能IO口
	参数一：
		如GPIO5  对应是MTDO_U
		如GPIO12  对应是MTDI_U
		最后加前缀 PERIPHS_IO_MUX_MTDO_U   ，PERIPHS_IO_MUX_MTDI_U
	参数二：(有两种表达方式)
		计算，查表普通GPIO5的普通IO口是Function4，则 4-1 = 3 。-1是因为从Function1开始算 由单片机都是从0 开始计数所以-1。
		加前缀，GPIO5的普通IO口是  FUNC_GPIO5   (宏定义在eagle_soc.h) 
		
	//GPIO5管脚设置为普通IO口功能，查表是Function4，那么值需要-1就是3。
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,3);
	//GPIO5管脚设置为I2SO_BCK功能，查表是Function2,那么值需要-1就是1。
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,1);
	//GPIO12脚设置为普通IO口
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12)

	如何查表 如GPIO15是MTDO_U ，看表找到MTDO_U的那一行 ，Function 就是引脚类型
*/
PIN_FUNC_SELECT(PIN_NAME,FUNC)  //引脚名字，管脚的功能

//管脚模式，管脚电平
/*
	GPIO_OUTPUT_SET  有时候会有bug会收不到数据
	固定写法 GPIO_ID_PIN(n)  n就是gpio引脚  
*/
GPIO_OUTPUT_SET(GPIO_ID_PIN(2),0) //  设置GPIO2为输出模式，输出低电平
```

	![[ESP8266的GPIO对应的名称.PNG]]
	![[ESP8266的GPIO对应的名称查表.PNG]]
	

##### GPIO相关寄存器
一、寄存器读写函数
```c
//GPIO口寄存器的读/写 函数  参数根据业务寄存器  
gpio_status= GPIO_REG_READ(GPIO_STATUS_ADDRESS);
GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);  
```
二、GPIO 输出寄存器 
```c
GPIO_ENABLE_W1TS //输出使能寄存器 
GPIO_ENABLE_W1TC //输出禁用寄存器 
GPIO_ENABLE  //输出使能状态寄存器
GPIO_OUT_W1TC //输出低电平寄存器 
GPIO_OUT_W1TS //输出高电平寄存器 
GPIO_OUT  // 输出状态寄存器  
```
三、GPIO 输入寄存器
```c
GPIO_IN //输入状态寄存器
```
四、GPIO 中断寄存器
```c
GPIO_PIN12 //中断类型寄存器(中断禁用，上升沿触发，下降沿触发，双沿触发，低电平，高电平)
GPIO_STATUS //中断状态寄存器
GPIO_STATUS_W1TC //清中断寄存器

```
五、GPIO16(XPD_DCDC) 不属于通用GPIO模块，属于RTC模块
```c
	 //可以用来在深度睡眠时候唤醒整个芯片，可以配置为输入或者输出模式，但无法触发 IO 中断。使用接口如下：

gpio16_output_conf(void){
	//将 GPIO16 配置为输出模式
}; 

gpio16_output_set(uint8 value){
	//从 GPIO16 输出高电平/低电平，需要先配置为输出模式
}; 

gpio16_input_conf(void){
	//将 GPIO16 的输入电平状态，需要先配置为输入模式
};
gpio16_input_get(void){
	 //读取 GPIO16 的输入电平状态，需要先配置为输入模式。
};
```
**以配置GPIO12 寄存器为示例**
	1、GPIO12 为普通IO口
	2、GPIO12 输出高电平
	3、使能 GPIO12上拉
	4、获取GPIO12管脚的电平状态
```c
/*
本质上是对PERIPHS_IO_MUX_MTDI_U寄存器的第4位和第5位置1
*/
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12); //GPIO12 为普通IO口

/*
本质上是对GPIO_ENABLE_W1TS 的寄存器第12位写1，表示使能gpio12输出功能
本质上是对GPIO_OUT_W1TS 的寄存器第12位写1，表示将gpio12输出为高电平
*/
GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 1); //GPIO12 输出高电平

/*
本质上是对PERIPHS_IO_MUX_MTDI_U 的第7位写1，表示使能gpio12的上拉功能
*/
PIN_PULLUP_EN(PERIPHS_IO_MUX_MTDI_U); //使能 GPIO12上拉

PIN_PULLUP_DIS(PERIPHS_IO_MUX_MTDI_U); //关闭 GPIO12的上拉

PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12);//GPIO12 为普通IO口
GPIO_DIS_OUTPUT(GPIO_ID_PIN(12));//配置 GPIO12 为输入模式


//本质上是获取 GPIO_IN 寄存器第 12 位的状态 ,前提是需要使能为输入模式，状态才能获取到
//如果level 为1 是高电平， 0 是低电平
Uint8 level = 0;
level = GPIO_INPUT_GET(GPIO_ID_PIN(12));//获取GPIO12管脚的电平状态

```

##### 初始化GPIO示例
```c
#include "eagle_soc.h"
#include  "gpio.h"

//配置管脚
PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO2_U, FUNC_GPIO2);

//禁止管脚输出
GPIO_DIS_OUTPUT(GPIO_ID_PIN(12));

//禁止内部上拉
PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO2);
//使能内部上拉
PIN_PULLUP_EN(PERIPHS_IO_MUX_GPIO2);

//读取管脚电平状态
GPIO_INPUT_GET(GPIO_ID_PIN(12));
//输出管脚电平状态
GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0);

//喂狗
system_soft_wait_feed(); 
```
外设初始化示例
```c
driver_lib/driver/Peripherals.c
//LED GPIO初始化
void LED_GPIO_Init (void){
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTDO_U, FUNC_GPIO15) ; //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (15), 0);//设置GPIO为输出模式 设置GPIO输出电平为高电平
}

//蜂鸣器GPIO初始化
void FM_GPIO_Init (void){
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12); //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (12), 0);//设置GPIO为输出模式设置GPIO输出电平为高电平
}

//继电器GPIO初始化
void RELAY_GPIO_Init (void){
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTCK_U, FUNC_GPIO13) ; //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (13), 0) ;//设置GPIO为输出模式设置GPIO输出电平为高电平
}
```
调用示例
```c
void ICACHE FLASH ATTR 
user _init (void)
{
	LED_GPIO_Init (); //LED GPIO引脚初始化
	FM_GPIO_Init (); //蜂鸣器GPIO初始化
	RELAY_GPIO_Init(); //继电器GPIO初始化
	while (1)
		{
			system_soft_wdt_feed();//喂狗
			LED_ON();
			FM_ON();
			RELAY_ON();
			delay_ms (1000) ;
			system_soft_wdt_feed (); //喂狗
			LED_OFF();
			FM_OFF();
			RELAY_OFF();
			delay_ms (1000);
		}
}
```


#### 2、UART(配套示例UART)
**参考文档：（p63）**
	esp8266-technical_reference_cn.pdf
##### 基础熟记
![[ESP8266的串口时序.PNG]]
**发送**： 低位前高位后 `bit0 ~ bit7`  顺序
**共10bit**  1起始 8bit 1停止，`11520个/秒 *10 = 115200bps`
**校验位**
```plaintext
奇校验：10101001  则  凑1变成奇数个101010011 
偶校验：10101001 则  凑1变成偶数个101010010
0校验 ：直接拼接0
1校验 ：直接拼接1
无校验则不加
```
**有校验位的数据包**：起始位，有效数据，校验位，停止位。
**屏蔽上电打印：** 没什么好办法只能改引脚，把上电默认的引脚改为别的引脚，串口工具只会去读默认引脚。
```c
// 举例
system_uart_swap(){
//U0TXD，U0RXD  改为对应U0RTS（MTDO/GPIO15），UOCTS(MTCK/GPIO13)
//烧录还走U0TXD 和 U0RXD
//GPIO15  对应RXD
//GPIO13  对应 TXD
}
```
**上电打印乱码原因**
```plaintext
	esp8266-F 有两个分别是UART0 和 UART1，烧录默认用UART0。
	UART0 默认开启，UART1默认关闭。 
	ESP8266芯片本身支持26MHz 和40MHz 的晶振，若使用40MHz晶振，则默认波特率为115200，若使用26MHz晶振，则UART0上电后的波特率 = 26*115200/40 = 74880。
	安信可的ESP8266系列模组均使用26MHz，由于一般的串口工具不会支持这个波特率，所以上电时会有打印乱码。得用带有74880的串口助手
```
**UART0、UART1区别**
```plaintext
UART0: 既有发送引脚(TXD)也有接收引脚(RXD)
    U0TXD: pin26(U0TXD)
    U0RXD: pin25(U0RXD)
    U0CTS: pin12(MTCK)
    U0RTS: pin13(MTDO)
UART1:而 UART1 只有发送引脚(TXD)引脚为 GPIO2
    U1TXD: pin14(GPIO2)
```
##### 常用的API(通常main.c是这么去写)
	1、头文件 (目录\driver_lib\driver\)
	2、初始化
	3、发送字符串函数
	4、系统打印函数来打印串口写法
```c
//头文件  
uart.c
uart.h 
uart_register.h

//初始化
void uart_init(115200,115200);  //UART0波特率，UART1波特率

 //发送字符串函数
uart0_sendStr("\r\n Hello Word! \r\n"); 串口0的发送字符串函数
uart1_sendStr_no_wait("\r\n Hello Word! 1 \r\n"); //串口1的发送字符串函数
//系统打印函数来打印串口写法
UART_SetPrintPort(UART1);  //参数UART号， UART0 或者 UART1
```

##### API集合(驱动uart.c用到的)
	1、设置串口数据长度
	2、设置停止位长度
	3、设置反相
	4、设置校验位使能和校验方式
	5、设置波特率
	6、设置流量控制也就是串口接收中断阈值 (还得配置中断寄存器所以api和宏比较多)
```c
//数据位
	#define UART_BIT_NUM 0x00000003 //数据位长度占用两个bit
	设置这两个bit可以配置数据长度0:5bit; 1:6bit；2:7bit；3:8bit
	#define UART_BIT_NUM_S    2     //寄存器偏移为2（第2bit开始）
void UART_SetWordLength(uint8 uart_no, UartBitsNum4Char len);

//停止位
	#define UART_STOP_BIT_NUM    0x00000003    //数据位长度占用两个bit
	设置这两个bit可以配置停止位长度 1:1bit；2:1.5bit；3:2bit
	#define UART_STOP_BIT_NUM_S    4    // 寄存器偏移为4(第4bit开始)
void UART_SetStopBits(uint8 uart_no, UartStopBitsNum bit_num);

//反相
    UART 各个信号输入与输出信号，可在内部进行反向配置
    #define UART_DTR_INV    （BIT(24)）
    #define UART_RTS_INV     (BIT(23))
    #define UART_TXD_INV     (BIT(22))
    #define UART_DSR_INV     (BIT(21))
    #define UART_CTS_INV     (BIT(20))
    #define UART_RXD_INV     (BIT(19))
    将对应寄存器置位，可以将对应信号线反向输出/输入。
void UART_SetLineInverse(uint8 uart_no, UART_LineLevelInverse inverse_mask);

//校验位
#define UART_PARITY_EN (BIT(1)) 校验使能：1：enable; 0：diable
#define UART_PARITY    (BIT(0)) 校验类型设置 1：奇校验；0：偶校验
void UART_SetParity(uint8 uart_no, UartParityMode Parity_mode);

//波特率 300 ~ 115200*40
void UART_SetBaudrate(uint8 uart_no,uint32 baud_rate);


//流量控制配置过程：
/* a. 先配置uart0的pin12，pin13脚复用为U0CTS,和U0RTS功能。*/
#define FUNC_U0RTS    4
#define FUNC_U0CTS    4
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, FUNC_U0RTS);
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, FUNC_U0CTS);
    
/*b. 接收方向的硬件流控可以配置阀值，当 rx fifo 中的长度大于所设的阀值， U0RTS脚就会拉高，阻止对方发送。
    配置接收流控制阀：
    阀值相关的配置一般都在UART_CONF1定义的寄存器中
    */
#define UART_RX_FLOW_EN (BIT(23))  // 第23bit使能接收流控: 0:disable; 1:enable
#define UART_RX_FLOW_THRHD 0x0000007F  // 门限值，占用7bit，范围0~127
#define UART_RX_FLOW_THRHD_S    16   // 寄存器偏移为16 (第16bit开始)

/* c. 发送方向的流控只需配置使能，该寄存器在UART_CONF0中：*/ 
  
#define UART_TX_FLOW_EN    (BIT(15))   // 使能发送流控: 0:disable; 1:enable
void UART_SetFlowCtrl(uint8 uart_no,UART_HwFlowCtrl flow_ctrl,uint8 rx_thresh);
void UART_WaitTxFifoEmpty(uint8 uart_no , uint32 time_out_us); /*do not use if tx flow control enabled*/
void UART_ResetFifo(uint8 uart_no);
void UART_ClearIntrStatus(uint8 uart_no,uint32 clr_mask);
void UART_SetIntrEna(uint8 uart_no,uint32 ena_mask);


//切换打印函数输出端口
/*   
	默认情况下，系统打印函数 os_printf 从 uart0 口输出内容，通过以下接口可以设置从 uart0 或者 uart1 口输出打印。
*/
void UART_SetPrintPort(uint8 uart_no);
bool UART_CheckOutputFinished(uint8 uart_no, uint32 time_out_us);
```
##### 配置串口接收中断（什么时候退出接收状态这部分在uart.c）
```plaintext
	由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数 UART_INT_ST(uart_no),软件可以在同一个中断服务函数里处理多个中断事件
(多个并列的if语句)。
```
**用到的寄存器**
```plaintext
uart的中断寄存器有：
    UART_INT_RAW 中断原始状态寄存器
    UART_INT_ENA 中断使能寄存器：表示当前使能的uart中断
    UART_INT_ST 中断状态寄存器：表示当前有效的中断状态
    UART_INT_CLR 清除中断寄存器：置对应位来清除中断状态寄存器
 
接口：
    打开中断使能：UART_ENABLE_INTR_MASK(uart_no, ena_mask)；
    关闭中断使能：UART_DISABLE_INTR_MASK(uart_no, disable_mask);
    清除中断状态：UART_CLR_INTR_STATUS_MASK(uart_no, clr_mask);
    获取中断状态：UART_GET_INTR_STATUS(uart_no);
```
**用到的宏定义（串口接收中过程会触发的三种中断，用宏封装）**	
** 区别在于：**
		一个是手动分长度超过了长度则触发，人为设置阀值并且数据不会丢失。
		一个是自动但是超过了（系统）默认的最大长度，溢出中断触发则一般都会存在数据丢失。
		一个是开始接收数据后，长时间内没有接收到则表示结束接收。
**总结：**
	阈值、使能、清除状态。（即手动设置长度也叫full中断）
	溢出、使能、清除状态。（在没有配置阈值时候就用这个即自动溢出中断）
	超时、使能、清除状态。（也叫tout中断）
**一、full中断 (中断状态位：UART_RXFIFO_FULL_INT_ST)**
```plaintext
	说明：rx(接收)fifo数据比较长要用到，比如,配置阀值为100，并使能full中断，当串口收到100字节后，会触发full中断。
    
    1、配置 full中断阀值(或门限值)：(在UART_CONF1寄存器)
    #define UART_RXFIFO_FULL_THRHD    0x0000007F    // 门限值mask,7bit长,范围0-127
    #define UART_RXFIFO_FULL_THRHD_S  0    // 寄存器偏移为0 (第0bit开始)
    
    2、设置full中断使能：(在UART_INT_ENA寄存器的bit0)
    #define UART_RXFIFO_FULL_INT_ENA  (BIT(0))    // 1:enable; 0:disable
    
    3、清除full中断状态：
		对于full中断比较特殊，需要先将接收fifo中的数据全部读空，然后写清楚中断状态寄存器。否则推出后，中断状态位还是会被置上。
    
```
**二、溢出中断 (中断状态位：UART_RXFIFO_OVF_INT_ST)**
```plaintext
    说明：当接收队列的长度大于队列总长度(128bytes)时，会触发该中断信号。
    
    1、设置溢出中断使能：(在UART_INT_ENA寄存器的bit4)
    #define UART_RXFIFO_OVF_INT_ENA    (BIT(4))  // 1:enable; 0:disable
    
    2、清除中断状态：
	    读取队列值，使队列长度小于128，然后置清除中断状态寄存器即可。
```
**三、tout超时中断 (中断状态位：UART_RXFIFO_TOUT_INT_ST)**
```plaintext
    说明：当uart开始接收数据后，停止传输的时间超过所设定的门限值，就
会触发tout中断。

    1、配置tout中断阀值（或门限值）：(在UART_CONF1寄存器中)
    Tout阀值的单位为8个uart数据比特的时间(近似一个byte)
    #define UART_RX_TOUT_EN    (BIT(31))    // 超时功能使能位：1：enable；0：disable
    #define UART_RX_TOUT_THRHD 0x0000007F   // 超时阀值配置位，共7位，范围0-127
    #define UART_RX_TOUT_THRHD_S 24         // 寄存器偏移为24 (第24bit开始)
    
    2、设置tout中断使能：(在UART_INT_ENA寄存器的bit8)
    #define UART_RXFIFO_TOUT_INT_ENA    (BIT(8))  // 1:enable;0:disable 
    
    3、清除中断状态：
	    与full中断类似，tout中断也需要先将接收fifo中的数据全部读空，然后写清除中断状态寄存器，否则退出后中断状态还是会被置上。
```

**四、full和tout 在uart.c   91行 是怎么配置寄存器的**
	把宏和寄存器 用接口 去设置
```C
//通过 WRITE_PERI_REG 给 uart0  配置UART_CONF1 寄存器 即 接收中断

//配置 full中断阀值100 
//7f & 100 =  0111 1111 &0110 0100 = 0110 0100     << 0   即值移动 0bit

//配置中断阀值
 WRITE_PERI_REG(
		 UART_CONF1(uart_no),
        ((100 & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S)|
        (0x02 & UART_RX_TOUT_THRHD) << UART_RX_TOUT_THRHD_S |
        UART_RX_TOUT_EN|
        ((0x10 & UART_TXFIFO_EMPTY_THRHD)<<UART_TXFIFO_EMPTY_THRHD_S));|
       SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_TOUT_INT_ENA |
       UART_FRM_ERR_INT_ENA
  );
 //清除状态
 WRITE_PERI_REG(UART_INT_CLR(uart_no), 0xffff);
 //使能中断
 SET_PERI_REG_MASK(
	 UART_INT_ENA(uart_no), 
	 UART_RXFIFO_FULL_INT_ENA|
	 UART_RXFIFO_OVF_INT_ENA
);

```


#### 3、GPIO中断（配套示例GPIO_EXIT在GPIO配置后配置GPIO中断）
**注意：**
	只有输入中断，没有输出中断。
	在中断服务函数内，不应该去写阻塞的逻辑（如延时）。
**参考文档：（p63）**
	手把手教你学ESP8266 NONOSDK开发指南——樱桃丸子单片机技术支持.pdf	
##### 基础熟记
	1、关闭 GPIO 中断
	2、配置 GPIO 的中断触发方式，该结构体在 gpio.h 中声明
	3、注册中断处理函数
	4、打开 GPIO 中断
	5、读取 GPIO 中断标志位
	6、清除 GPIO 中断标志位
```c
//关闭 GPIO 中断
ETS_GPIO_INTR_DISABLE()

//配置 GPIO 的中断触发方式，该结构体在 gpio.h 中声明
void gpio_pin_intr_state_set( uint32 i, GPIO_INT_TYPE intr_state){
	//uint32 i: GPIO 引脚 ID
	/*
		typedef enum{
			GPIO_PIN_INTR_DISABLE= 0,//禁止中断
			GPIO_PIN_INTR_POSEDGE= 1,//上升沿触发
			GPIO_PIN_INTR_NEGEDGE= 2,//下降沿触发
			GPIO_PIN_INTR_ANYEDGE= 3,//双边沿触发
			GPIO_PIN_INTR_LOLEVEL= 4,//低电平触发
			GPIO_PIN_INTR_HILEVEL= 5//高电平触发
		} GPIO_INT_TYPE;
	*/
}
//例子：配置 GPIO14 引脚为下降沿触发。
gpio_pin_intr_state_set(GPIO_ID_PIN(14)，GPIO_PIN_INTR_NEGEDGE);

//注册中断处理函数
ETS_GPIO_INTR_ATTACH(func, arg){
	//Func:中断服务函数函数名
	//arg:传入的参数
}

//打开 GPIO 中断
ETS_GPIO_INTR_ENABLE()

//读取 GPIO 中断标志位
uint32 gpio_status; //用于存中断标志位，为了清除时候用
gpio_status= GPIO_REG_READ(GPIO_STATUS_ADDRESS);// GPIO_STATUS_ADDRESS是 整个gpio口的状态寄存器

//清除 GPIO 中断标志位
GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);//清除中断标志位
```

##### GPIO中断示例(如GPIO5作为key,搭配个中断作为自动触发逻辑)
	这里以key.c 为demo，123是必须要的，34的内容根据实际业务去写，但基本有模板，加ICACHE_FLASH_ATTR 是目的存储起来。 
	1、先初始化用作key的GPIO
	2、去初始化配置搭配的key的中断
	3、去定义key触发中断时的中断服务函数
	4、定义（封装起来复用）一些检测key的GPIO的一些逻辑代码
```c
#include "./driver/key.h"
#include "gpio.h"
#include <eagle_soc.h>
#include "./driver/Peripherals.h"

void ICACHE_FLASH_ATTR KEY_GPIO_Init(void){  //按键GPIO初始化
    PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U,FUNC_GPIO5);//设置GPIO5引脚的功能为GPIO
    GPIO_DIS_OUTPUT(GPIO_ID_PIN(5));  //设置GPIO为输入模式 禁止GPIO输出
    PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO5_U); //禁止内部上拉
}
```

```c
//GPIO外部中断初始化
void ICACHE_FLASH_ATTR GPIO_EXIT_Init(void){
    KEY_GPIO_Init();  //配置相关GPIO为GPIO输入模式
    ETS_GPIO_INTR_DISABLE(); //关闭GPIO中断 
    gpio_pin_intr_state_set(GPIO_ID_PIN(5), GPIO_PIN_INTR_NEGEDGE);  //配置GPIO触发引脚5和触发下降沿模式
    ETS_GPIO_INTR_ATTACH((ets_isr_t)GPIO_EXIT_Interrupt, NULL); //注册中断服务函数 GPIO_EXIT_Interrupt 函数名 没有传入参数为NULL
    ETS_GPIO_INTR_ENABLE(); //中断使能
}
```

```c
/*************************************************************************
 * FunctionName : GPIO外部中断中断服务函数
 * Description  : 主要是做按键检测到电平变化则认为是按下或松开按键，按下led亮松开灭。(之前demo是不用外部中断检测电平变化，是直接在main进行检测GPIO口高低电平，在单片机开发中应该用外部中断检测电平变化替代GPIO高低电平变化检测思路，因为存在bug单片机多少都会漏检测到的bug缺陷可能是库函数问题)
*************************************************************************/ 
void GPIO_EXIT_Interrupt(void){
    uint32 gpio_status;  //用于存中断标志位，为了清除时候用
    static uint8_t LED_Flag=0;
    gpio_status = GPIO_REG_READ(GPIO_STATUS_ADDRESS);   //读取中断状态寄存器的值  整个GPIO口的状态寄存器拿到了去查pin5
    /*
    因为是设置的pin5脚也就是中断5所以左移5到指定的bit位置
	   如: 12个引脚就有 12bit pin5就是移到5bit位置(单片机通用知识)
    */
	 if((gpio_status&(1<<5))) {    //判断是哪一个GPIO引起的中断
        os_delay_us(4000);      //软件消抖
        if(GPIO_INPUT_GET(GPIO_ID_PIN(5))==0){
            LED_Flag=!LED_Flag; //切换led灯亮灭
            if(LED_Flag==0){
                LED_ON();
            }else{
                LED_OFF();
            } //LED_Flag==0
        } //GPIO_INPUT_GET(GPIO_ID_PIN(5))==0
    } //(gpio_status&(1<<5))
    GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);  //清除中断
} //GPIO_EXIT_Interrupt
```

```c
//按键扫描成函数
//参数mode：0：不支持连续按键      1：支持连续按键
//返回1：按键被按下 返回0：按键不被按下
uint8_t ICACHE_FLASH_ATTR Key_Scan(uint8_t mode)
{
    static uint8_t key_flag=0;
    if(mode==1)     //支持连续按键
        key_flag=0;
    if((KEY_STATUS==0&&key_flag==0))
    {
        os_delay_us(5000);  //软件消抖
        if(KEY_STATUS==0 && key_flag==0)
        {
            key_flag=1;
            return KEY_ON;
        }
    }
    else if(KEY_STATUS==1)
    {
       key_flag=0;
    }
    return KEY_OFF;
}
```


#### 4、软件定时器(配套示例OS_Timer)
**目的：**
	替代延时代码更精准，但是定时器函数在执行过程，可能被其他中断或高优先级的给延迟。所以os_timer 接口其实也不那么精准。一定非要很精准就得用硬件中断定时器替代。
**注意：**
	1、一个定时器的 `os_timer_arm或os_timer_arm_us `不能重复调用。
	2、`os_timer_setfn` 必须在timer未使能的情况下调用。
##### 基础熟记
	1、头文件
	2、关闭软件定时器
	3、注册定时器回调函数
	4、使能毫秒定时器
```c
//头文件
#include  "./include/osapi.h"
os_timer_t os_timer_1; 
//关闭软件定时器
os_timer_disarm(&os_timer_1);  
//注册定时器回调函数
 os_timer_setfn(&os_timer_1,(os_timer_func_t*)OS_Timer_1_Cb,NULL);
//使能毫秒定时器
 os_timer_arm(&os_timer_1,ms,repeat_flag);
```
##### API 函数集合
调用顺序
```plaintext
1、os_timer_disarm
2、os_timer_setfn   //得在disarm 后， arm前
3、os_timer_arm 或 os_timer_arm_us
```
一、os_timer_arm （使能毫秒级定时器）
```c
void os_timer_arm (os_timer_t *ptimer,uint32_t milliseconds,bool repeat_flag){
	/*
		os_timer_t *ptimer：定时器结构体
		uint32_t milliseconds：定时时间，单位：ms
			如未调用 system_timer_reinit，可支持范围 5 ~ 0x68D7A3
			如调用了 system_timer_reinit，可支持范围 100 ~ 0x689D0
		bool repeat_flag: 0:不重复定时器 1:重复定时
	*/
}
```

二、os_timer_disarm（取消定时器定时）
```c
void os_timer_disarm (os_timer_t *ptimer){	
	//os_timer_t *ptimer：定时器结构
}
```
三、os_timer_setfn（设置定时器回调函数。使⽤定时器，必须设置回调函数。）
```c
void os_timer_setfn(os_timer_t *ptimer,os_timer_func_t *pfunction,void *parg){
	// os_timer_t *ptimer：定时器结构
	// os_timer_func_t *pfunction：定时器回调函数
	// void *parg：回调函数的参数
}
```

一、system_timer_reinit（重新初始化定时器，当需要使⽤微秒级定时器时调⽤）
```c
/*
	同时定义 USE_US_TIMER
	system_timer_reinit 在程序最开始调⽤，user_init 的第⼀句。
*/
void system_timer_reinit (void){

}
```
二、os_timer_arm_us （使能微秒级定时器）
```c
/* 
请定义 USE_US_TIMER，并在 user_init 起始第⼀句，先调⽤ system_timer_reinit。
最⾼精度为 500 μs。
*/
void os_timer_arm_us (os_timer_t *ptimer,uint32_t microseconds,bool repeat_flag){
	//os_timer_t *ptimer:定时器结构体
	//uint32_t microseconds：定时时间，单位 us，最小 0x64,最大 0xFFFFFFF
	//bool repeat_flag：是否重复定时，0：不重复定时，1：重复定时
}
```

##### 示例(原本GPIO中断低电平触发示例改为软件定时触发)
软件定时器初始化示例os_timer.c
```c 
#include "./driver/os_timer.h"

os_timer_t os_timer_1;  //实例化一个对象 os_timer_t 在SDK库头文件提供
//软件定时器1回调函数   
void ICACHE_FLASH_ATTR OS_Timer_1_Cb(void){
	//业务逻辑
	  ....
} 
  
//软件定时器配置初始化
void ICACHE_FLASH_ATTR OS_Timer_Init(uint32_t ms,bool repeat_flag){
    os_timer_disarm(&os_timer_1); //关闭软件定时器
    os_timer_setfn(&os_timer_1,(os_timer_func_t*)OS_Timer_1_Cb,NULL); //注册软件定时回调函数
    os_timer_arm(&os_timer_1,ms,repeat_flag); //打开软件定时器并设置定时时间以及是否重复
}
```
调用示例user_main.c
```c 
user_init(void){
	....
   OS_Timer_Init(500,1);  //软件定时器初始化
}
```

#### 5、硬件定时器(配套示例HW_Timer)
**注意：**
	1、使⽤ NMI 中断源，且为⾃动填装的定时器，调⽤ 毫秒定时函数 时参数 val 必
须⼤于 100。
	2、使⽤ NMI 中断源，那么该定时器将为最⾼优先级，可打断其他 ISR。
	3、使⽤ FRC1 中断源，那么该定时器⽆法打断其他 ISR。
	4、无法和PWM一起用，用的是同一组定时器
	5、回调函数不要加ICACHE_FLASH_ATTR 宏。
	6、如果用了wifi 睡眠模式 cpu 无法响应 NMI中断。
##### 基础熟记
	1、拷贝SDK-2.2.1\driver_lib\driver\的hw_timer.c文件非自己编写
	2、初始化硬件定时器
	3、注册定时器中断服务函数
	4、使能硬件中断定时器
```c
//初始化硬件定时器
hw_timer_init(NMI_SOURCE，1); //参数一可以写NMI_SOURCE 也可以简写1
//注册定时器中断服务函数
hw_timer_set_func(HW_Timer_Intrrupt);  //先定义好中断服务函数HW_Timer_Intrrupt
//使能硬件中断定时器 定时 500ms
hw_timer_arm(500000);
```
##### API 函数集合
一、hw_timer_init （初始化硬件 ISR 定时器）
```c
void hw_timer_init (FRC1_TIMER_SOURCE_TYPE source_type,u8 req){
	/*
	参数一：中断源 0： FRC1_SOURCE是FRC1 中断源  、1：NMI_SOURCE是NMI 中断源
	参数二：是否重装载  0不自动重装载、 1自动重装载
	*/
}
```

二、hw_timer_arm（使能硬件中断定时器）
```c
void hw_timer_arm (uint32 val)
/*
	参数是 定时时间
	情况一 NMI 自动重装载 ,取值范围100 - 0x199999μs(100us - 1,677,721us)
	情况二 FRC1 自动重装载 ,取值范围50-0x199999μs(50us-1,677,721us)
	情况三  非自动重装载模式，取值范围：10 - 0x199999μs
	
*/
```
三、hw_timer_set_func（设置定时器回调函数。使⽤定时器，必须设置回调函数。）
```c
void hw_timer_set_func (void (* user_hw_timer_cb_set)(void) ){
	//void (* user_hw_timer_cb_set)(void)：定时器回调函数（中断服务函数）
}
```

##### 示例()
软件定时器初始化示例hw_timer_driver.c
```c 
#include "./driver/hw_timer_driver.h" 
/*
 * 硬件定时器中断服务函数
 */
void HW_Timer_Intrrupt(void)
{
   //业务逻辑
   ....
}

/*
 * 函数名：硬件定时器初始化配置函数
 * 参数：us:定时时间    100us < us < 1677721us
 */
void ICACHE_FLASH_ATTR HW_Timer_Init(uint32_t us)
{
    if(us<100||us>1677721)
    {
        os_printf("us<100||us>1677721\r\n");
        return;
    }
    hw_timer_init(1,1);     //硬件定时器初始化 使用NMI中断源 重复定时
    hw_timer_set_func(HW_Timer_Intrrupt);   //注册硬件定时器中断服务函数
    hw_timer_arm(us);       //使能中断定时器并设置定时时间
    os_printf("HW_Timer OK!\r\n");
}
```
调用示例user_main.c
```c 
user_init(void){
	....
   HW_Timer_Init(500000); //硬件定时器初始化 定时周期500ms
}
```

#### 6、SPI Flash (配套示例Flash)
**理解：**
	 bin就是存FLASH,4Mbyte经过换算扇区编号范围0x000 – 0x3FF，可以存储代码和存储数据，掉电复位不丢失。
**注意：**
	1、读写Flash 必须从0x70 000地址后面。
	2、4k对齐。
	3、写前先擦除。擦除函数参数是扇区编号不是地址。
	4、读写函数参数是字节地址不是扇区编号。
##### 基础熟记
	1、拷贝./include/spi_flash.h
	2、获取 FLASH 的 ID 号
	3、擦除 Flash 扇区
	4、往 FLASH 写入数据
	5、从 FLASH 读取数据
```c
//获取 FLASH 的 ID 号
os_printf("\r\nspi_flash_get_id=%d\r\n\r\n",spi_flash_get_id());
//擦除 Flash 扇区
spi_flash_erase_sector((uint16_t) 0x77); //存储数据的扇区编号

//往 FLASH 写入数据 
//Read_Data 为数组名
spi_flash_write(0x77 * 4096,(uint32_t *)Write_Data,sizeof(Write_Data));

//从 FLASH 读取数据
//Read_Data 为数组名
spi_flash_read(0x77 * 4096,(uint32_t *)Read_Data,sizeof(Write_Data));


```
##### API 函数集合
一、spi_flash_get_id （查询 SPI Flash 的 ID）
```c
uint32  spi_flash_get_id = uint32 spi_flash_get_id (void);
```
二、spi_flflash_erase_sector（写flash之前必须先擦除扇区）
```c
// 4k 对齐就是 每个扇区4k  4096 传入的参数必须是倍数
SpiFlashOpResult spi_flash_erase_sector (uint16 sec){
	/*返回值
	typedef enum{ 
		SPI_FLASH_RESULT_OK,//写 FLASH 成功
		SPI_FLASH_RESULT_ERR,//写 FLASH 错误
		SPI_FLASH_RESULT_TIMEOUT//写 FLASH 超时
	}SpiFlashOpResult;
	*/
}
```
三、spi_flash_write（写⼊数据到 Flash）
```c
SpiFlashOpResult spi_flash_write (uint32 des_addr,uint32 *src_addr,uint32 size)


/*
	参数 
		uint32 des_addr：写⼊ Flash ⽬的地址
		uint32 *src_addr：写⼊数据的指针
		uint32 size：数据⻓度，单位 byte，必须 4 字节对⻬进⾏读写
	返回值
	typedef enum{ 
		SPI_FLASH_RESULT_OK,//写 FLASH 成功
		SPI_FLASH_RESULT_ERR,//写 FLASH 错误
		SPI_FLASH_RESULT_TIMEOUT//写 FLASH 超时
	}SpiFlashOpResult;
*/
```
四、spi_flash_read（从 Flash 读取数据） 
```c
SpiFlashOpResult spi_flash_read (uint32 des_addr,uint32 *src_addr,uint32 size)

/*
	参数 
		uint32 des_addr：Flash 的哪个地址取
		uint32 *src_addr：存放读取到的数据存放的地址
		uint32 size：数据⻓度，单位 byte，必须 4 字节对⻬进⾏读写
	返回值
	typedef enum{ 
		SPI_FLASH_RESULT_OK,//写 FLASH 成功
		SPI_FLASH_RESULT_ERR,//写 FLASH 错误
		SPI_FLASH_RESULT_TIMEOUT//写 FLASH 超时
	}SpiFlashOpResult;
*/
```
五、system_param_save_with_protect（使⽤带读写保护机制的⽅式，写⼊数据到 Flash）
```c
bool system_param_save_with_protect (uint16 start_sec,void *param,uint16 len)
/*
	参数 
		uint16 start_sec：读写保护机制使⽤的 3 个 sector 的起始 sector 0 值。
例如，IOT_Demo 中可使⽤ 0x3D000 开始的 3 个 sector（3×4 KB）建⽴读写保护机制，则
参数 start_sec 传 0x3D。
		void *param：写⼊数据的指针
		uint16 len：数据⻓度，不能超过 1 个 sector ⼤⼩，即 4×1024
	返回值
		true：成功
		false：失败
*/

```
六、system_param_load（使⽤带读写保护机制的⽅式，读出数据到 Flash）
```c
bool system_param_load (uint16 start_sec,uint16 offset,void *param,uint16 len)
/*
	参数 
		uint16 offset：需读取数据，在 sector 中的偏移地址
	返回值
		true：成功
		false：失败
*/
```
七、spi_flflash_set_read_func（注册⽤户⾃定义的 SPI Flash 读取接⼝函数）
```c
//仅⽀持在 SPI overlap 模式下使⽤

```
八、spi_flflash_erase_protect_enable（使能 flash 擦写保护）
```c

```
九、spi_flflash_erase_protect_disable（关闭 flash 擦写保护功能）
```c

```
##### 示例
测试flash.c
```c 
#include "./driver/flash.h"


uint32_t Write_buf[10]={89,2,3,4,5,6,7,8,9,0};
uint32_t Read_buf[10]={0};

#define Sector		0x90  //扇区
#define Sector_size 4096

//Flash读写测试程序
void ICACHE_FLASH_ATTR Flash_Write_Read_Test(void)
{
	uint8_t i=0;
	os_printf("FLash ID=%d\r\n",spi_flash_get_id());	//获取flash的ID

	spi_flash_erase_sector(Sector);	//擦除对应的扇区
	spi_flash_write(Sector*Sector_size,(uint32_t *)Write_buf,sizeof(Write_buf));	//往FLASH写入数据
	spi_flash_read(Sector*Sector_size,(uint32_t *)Read_buf,sizeof(Read_buf));		//从FLASH中读取数据
	for(i=0;i<10;i++)
		os_printf("Read_buf[i]=%d\r\n",Read_buf[i]);
}

```
调用示例user_main.c
```c 
user_init(void){
	....
   Flash_Write_Read_Test();
}
```

#### 7、用户任务(配套示例Task)
**优先级：**
	分为三个优先级：0、1、2。任务优先级为 2>1>0
	最多支持 3 个用户任务，优先级分别为 0、1、2。
**了解：**
	用户代码长时间占用cpu，会触发看门狗复位。所以要喂狗。
	用户任务常常用于为u发被直接调用的函数。比如 ：`TCP/UDP`是不能在esp8266回调里执行。所以得在回调函数里创建一个用户任务，把相关代码放这里面执行。

##### 基础熟记
	1、创建系统任务，最多支持创建 3 个任务，优先级分别为 0，1，2
	2、给系统安排任务 
```c
//创建系统任务
#define TASK1_QUEUE_LEN   3  //定义消息队列深度
#define SIG_RX 0// 定义任务消息参数类型
os_event_t *task1_queue=NULL;//定义消息队列指针
task1_queue=(os_event_t*)os_malloc(sizeof(os_event_t)*TASK1_QUEUE_LEN);
system_os_task(Task1,0,task1_queue,TASK1_QUEUE_LEN);

//给系统安排任务
#define SIG_RX 0 //定义任务消息参数类型
system_os_post(0,SIG_RX,0);

```
##### API 函数集合
一、system_os_task（创建系统任务，最多⽀持创建 3 个任务，优先级分别为 0/1/2）
```c
bool system_os_task(os_task_t task,uint8 prio,os_event_t *queue,uint8 qlen){
	/*
	参数
		os_task_t task：任务函数
		uint8 prio：任务优先级，可为 0/1/2；0 为最低优先级。这表示最多只⽀持建⽴ 3 个任务
		os_event_t *queue：消息队列指针
		uint8 qlen：消息队列深度
	*/
}
```
二、system_os_post（给系统安排任务）
```c
bool system_os_post (uint8 prio,os_signal_t sig,os_param_t par){
/*
	参数
		uint8 prio：任务优先级，与建⽴时的任务优先级对应。
		os_signal_t sig：消息类型 通过优先级判断这个是谁给的任务
		os_param_t par：消息参数
	返回
		true：成功
		false：失败
*/
}
```

##### 示例
测试flash.c
```c 
#include "./driver/flash.h"


uint32_t Write_buf[10]={89,2,3,4,5,6,7,8,9,0};
uint32_t Read_buf[10]={0};

#define Sector		0x90  //扇区
#define Sector_size 4096

//Flash读写测试程序
void ICACHE_FLASH_ATTR Flash_Write_Read_Test(void)
{
	uint8_t i=0;
	os_printf("FLash ID=%d\r\n",spi_flash_get_id());	//获取flash的ID

	spi_flash_erase_sector(Sector);	//擦除对应的扇区
	spi_flash_write(Sector*Sector_size,(uint32_t *)Write_buf,sizeof(Write_buf));	//往FLASH写入数据
	spi_flash_read(Sector*Sector_size,(uint32_t *)Read_buf,sizeof(Read_buf));		//从FLASH中读取数据
	for(i=0;i<10;i++)
		os_printf("Read_buf[i]=%d\r\n",Read_buf[i]);
}

```
调用示例user_main.c
```c 
user_init(void){
	....
   Flash_Write_Read_Test();
}
```

#### 8、PWM(配套示例PWM) 
**了解：**
	控制彩灯、蜂鸣器和电机等设备。
	通过FRC1 是⼀个 23 bits 的硬件定时器。
	用NMI 中断更精准。
	最多8路PWM信号。
	`>14bit`分辨率，最小分辨率4ms
	⽆需配置寄存器，调⽤函数接⼝即可完成配置。
	通过 80MHZ，用16预分频，变成5MHZ，用FRC1 来产⽣粗调定时，最快可以到45ns。PWM 波信号周期为1000us-10000us，对应频率为 1kHz-100Hz 。
##### 基础熟记
	1、头文件pwm.h
	2、初始化 PWM 配置输出的 GPIO、周期、占空比
	3、PWM 开始输出
	4、设置占空比 (设置后需要调用 pwm_start();才有效)
	5、设置周期 (设置后需要调用 pwm_start();才有效)
	6、获取某路通道反馈实际的占空比
	7、获取反馈实际周期
	8、查询 PWM 的版本信息
```c
#include "pwm.h"
//初始化 PWM 配置输出的 GPIO、周期、占空比
struct pwm_param PWM_Param_Struct={1000,1000,{0}};
pwm_init(PWM_Param_Struct.period,PWM_Param_Struct.duty,1,PWM_IO_Info);

//PWM 开始输出
//每一次更改了 PWM 的设置的时候都需要调用此函数，因为此函数内部进行了相应的计算。
pwm_start();
 
//设置占空比 
/*
duty 不是实际的高电平时间
duty最大取值 =  Period(频率) * 1000 /45

如输出1khz 的pwm波 求出 取值范围和 占空比？ 

duty取值范围是 1000* 1000 /45 =22222.222  范围也就是 0-22222 
占空比： 
(实际duty)/(duty最大值) = duty /(Period *1000/45)=duty*45/Period/1000
*/
pwm_set_duty(100,0); //设置通道 0 的 duty 为 100

//设置周期 
/*
	单位 us。稳定的 PWM 输出周期范围1000us-10000us
*/
pwm_set_period(1000);//设置 PWM 周期为 1000


//获取某路通道反馈实际的占空比
/*经过计算，实际占空比= (duty*45)/ (period*1000)*/
uint8 pwm_get_duty(uint8 channel)
//获取反馈实际周期
uint32 pwm_get_period(void)
//查询 PWM 的版本信息
uint32 pwm_get_period(void)
```
##### API 函数集合
一、pwm_init（初始化 PWM，包括 GPIO 选择，周期和占空⽐。⽬前仅⽀持调⽤⼀次）
```c
void pwm_init(uint32 period,uint8 *duty,uint32 pwm_channel_num,uint32 (*pin_info_list)[3]){
	/*
	参数
		uint32 period：PWM 周期
		uint8 *duty：各路 PWM 的占空⽐
		uint32 pwm_channel_num：PWM 通道数
		uint32 (*pin_info_list)[3]：PWM 各通道的 GPIO 硬件参数。本参数是⼀个 n * 3 的数组指针，数组中定义了 GPIO 的寄存器，对应 PIN 脚的 IO 复⽤值和 GPIO 对应的序号
	*/
}
uint32 io_info[][3] =
{
	{PWM_0_OUT_IO_MUX,PWM_0_OUT_IO_FUNC,PWM_0_OUT_IO_NUM},
	{PWM_1_OUT_IO_MUX,PWM_1_OUT_IO_FUNC,PWM_1_OUT_IO_NUM},
	{PWM_2_OUT_IO_MUX,PWM_2_OUT_IO_FUNC,PWM_2_OUT_IO_NUM}
};
pwm_init(light_param.pwm_period, light_param.pwm_duty, 3, io_info);
```
二、pwm_start（每次更新 PWM 设置后，都需要重新调⽤本接⼝进⾏计算。）
```c
void pwm_start (void)
```
三、pwm_set_duty(设置某路 PWM 信号的 duty 参数)
```c
void pwm_set_duty(uint32 duty, uint8 channel){
/*
	参数
		占空比的值(duty*45)/ (period*1000)
		PWM通道	
*/

}
```
四、pwm_get_duty(获取某路 PWM 信号的 duty 参数)
```c
uint8 pwm_get_duty(uint8 channel){
	//PWM 通道
}
```
五、pwm_set_period(设置 PWM 周期)
```c
void pwm_set_period(uint32 period){
	/*
	参数
		单位：μs。例如，1KHz PWM，参数为 1000 μs。
	*/
}
```
六、pwm_get_period(查询 PWM 周期)
```c
uint32 pwm_get_period(void){
	//μs
}
	
```
七、get_pwm_version （查询 PWM 版本信息）
```c
uint32 get_pwm_version(void){
	
}
```

##### 示例
测试pwm_driver.c
```c 
#include "./driver/pwm_driver.h"
#include "pwm.h"
#include "eagle_soc.h"

//PWM????????
struct pwm_param PWM_Param_Struct={
	1000,1000,{0,0}
};

//PWM??????IO????
uint32_t PWM_IO_Info[2][3]={
	{PERIPHS_IO_MUX_MTDO_U,FUNC_GPIO15,GPIO_ID_PIN(15)},
	{PERIPHS_IO_MUX_GPIO2_U,FUNC_GPIO2,GPIO_ID_PIN(2)}
};

//PWM?????
void ICACHE_FLASH_ATTR PWM_Init(void){
 pwm_init(PWM_Param_Struct.period,PWM_Param_Struct.duty,2,PWM_IO_Info);  //pwm?????
}

```
调用示例user_main.c
```c 
user_init(void){
	....
   PWM_Init();
}
```


#### 9、WIFI(配套示例WIFI_XX_MODE) 
**了解：**
```plaintext
AP 与 STATION：
	AP，即基站，必须分配一个小于 32 字节的 WiFi 名 SSID，
	STATION，移动站。
	如家中，路由器就是 AP，手机就是 STATION。
	
wifi 用tcp协议也就是IP
	DHCP：动态主机配置协议,目的自动配置设备IP地址，子网掩码，默认路由器的IP 地址、域名服务器的 IP 地址

接口分为：查询、设置。
模式分为：AP 、STATION 。
```

##### 基础熟记
	AP
	1、设置 WiFi 的工作模式
	2、设置 WiFi SoftAP 模式，并保存到 flash
	3、查询 WiFi Station 模式或者 AP 模式的 IP 地址，确认模式是否配置成功
	4、获取 AP 模式下接入此 WiFi 的设备数量
	STA
	1、设置 WiFi 的工作模式
	2、设置 WiFi Station 模式并保存到 flash
	3、查询 ESP8266 Wi-Fi Station 接口连接 AP 的状态。
	4、查询 WiFi Station 模式或者 AP 模式的 IP 地址，确认模式是否配置成功
	自定义DHCP
	1、开启 DHCP
	2、关闭 DHCP
	3、设置 AP 模式或 STA 模式 IP 地址、子网掩码、网关 
```c
struct softap_config {
	uint8 ssid[32]; //WiFi 名
	uint8 password[64]; //密码
	uint8 ssid_len; //WiFi 名长度
	uint8 channel; //通道号 1 ~ 13
	AUTH_MODE authmode;//加密方，softAP模式不支持AUTH_WEP加密方式。
	uint8 ssid_hidden; //是否隐藏 WiFi，默认为 0 不隐藏网络
	uint8 max_connection; //最大连接设备数，最大设备数为 4
	uint16 beacon_interval;//信标间隔时间，支持 100-60000ms（信标间隔时间即 SSID 广播包发送的间距），默认为 100ms
};

//设置 WiFi 的工作模式
wifi_set_opmode(0x02);//设置 WiFi 工作模式为 AP 模式

//设置 WiFi SoftAP 模式，并保存到 flash
struct softap_config AP_Config_Struct;
os_strcpy(AP_Config_Struct.ssid,ESP8266_SSID);
os_strcpy(AP_Config_Struct.password,ESP8266_PASS);
AP_Config_Struct.ssid_len=sizeof("YTWZDPJJSZC");
AP_Config_Struct.authmode=AUTH_WPA2_PSK;
AP_Config_Struct.beacon_interval=100;
AP_Config_Struct.channel=1;
AP_Config_Struct.max_connection=4;
AP_Config_Struct.ssid_hidden=0;
wifi_softap_set_config(&AP_Config_Struct);

//查询 WiFi Station 模式或者 AP 模式的 IP 地址，确认模式是否配置成功
wifi_get_ip_info(SOFTAP_IF,&AP_IP_Info);

//获取 AP 模式下接入此 WiFi 的设备数量
uint8 wifi_ap_num = wifi_softap_get_station_num();
```

```c
//你要连接的wifi 的参数
struct station_config {
 uint8 ssid[32]; // WiFi 的名称
 uint8 password[64]; //WiFi 的密码
 uint8 bssid_set; //当一个局域网中有多个同名 WiFi 时使用
				  // bssid_set 为 1 时连接 WiFi 还将校验 MAC 地址
 uint8 bssid[6]; // WiFi 的 MAC 地址
 wifi_fast_scan_threshold_t threshold; //结构体，包含了 WiFi 的加密方
//式和信号强度两个变量
};

//返回值：所查询AP状态
enum{
	STATION_IDLE = 0, //空闲
	STATION_CONNECTING, //正在连接
	STATION_WRONG_PASSWORD, //密码错误
	STATION_NO_AP_FOUND, //没有发现 AP
	STATION_CONNECT_FAIL, //连接失败
	STATION_GOT_IP //获取到 IP
};



//设置 WiFi 的工作模式
wifi_set_opmode(0x01);

//设置 WiFi Station 模式并保存到 flash
os_strcpy(STA_Config_Struct.ssid,ESP8266_SSID);
os_strcpy(STA_Config_Struct.password,ESP8266_PASS);
wifi_station_set_config(&STA_Config_Struct);

//查询 ESP8266 Wi-Fi Station 接口连接 AP 的状态。
uint8 wifi_sta_status = wifi_station_get_connect_status();

//查询 WiFi Station 模式或者 AP 模式的 IP 地址，确认模式是否配置成功
wifi_get_ip_info(SOFTAP_IF,&AP_IP_Info);
```

```c
//开启 DHCP  返回值  true成功 ， false失败
wifi_station_dhcpc_start();

//关闭 DHCP  返回值  true成功 ， false失败
wifi_station_dhcpc_stop();

//设置 AP 模式或 STA 模式 IP 地址、子网掩码、网关
struct ip_info info; //定义一个 IP 信息结构体   ip_info由库函数封装好的
wifi_station_dhcpc_stop();//关闭 dhcp
IP4_ADDR(&info.ip,192,168,43,200); //设置 IP 地址
IP4_ADDR(&info.gw,192,168,43,1);//设置网关
IP4_ADDR(&info.netmask,255,255,255,0); //设置子网掩码
wifi_set_ip_info(STATION_IF,&info);
```

##### API 函数集合
一、wifi_get_opmode（查询 Wi-Fi 当前⼯作模式）
```c
uint8 wifi_get_opmode (void){
	/*
	返回
		0x01：Station 模式
		0x02：SoftAP 模式
		0x03：Station+SoftAP 模式
	*/
}
```
二、wifi_get_opmode_default（查询保存在 Flash 中的 Wi-Fi ⼯作模式设置）
```c
uint8 wifi_get_opmode_default (void){
	/*
		返回
			0x01：Station 模式
			0x02：SoftAP 模式
			0x03：Station+SoftAP 模式
	*/
}
```
三、wifi_set_opmode(设置 Wi-Fi ⼯作模式（Station，SoftAP 或者 Station+SoftAP），并保存到 Flash。默认为 SoftAP 模式)
```c
/*
	ESP8266_NONOS_SDK_V0.9.2 以及之前版本，设置之后需要调⽤ system_restart() 重启
⽣效；
	ESP8266_NONOS_SDK_V0.9.2 之后的版本，不需要重启，即时⽣效。
	本设置如果与原设置不同，会更新保存到 Flash 系统参数区。
*/
bool wifi_set_opmode (uint8 opmode){
/*
	参数 
		0x01：Station 模式
		0x02：SoftAP 模式
		0x03：Station+SoftAP 模式
	返回
		true：成功
		false：失败
*/
}
```
###### Wi-Fi Station
一、wifi_station_get_config(查询当前配置参数)
```c
bool wifi_station_get_config (struct station_config *config){
	/*
	参数 
		 接⼝参数指针
	返回
		true：成功
		false：失败
	*/
}
```
二、wifi_station_get_config_default(查询保存在 Flash 中的配置参数)
```c
bool wifi_station_get_config_default(struct station_config *config){
	/*
	参数 
		 接⼝参数指针
	返回
		true：成功
		false：失败
	*/
}
```
三、wifi_station_set_config(设置配置参数，并保存到 Flash)
wifi_softap_set_confifig(设置配置，并保存到 Flash)
此函数其实是在内核中完成的，不会一调用就直接配置
```c
/*
	在 ESP8266 Station 使能的情况下，调⽤本接⼝。
	如果在 user_init 中调⽤，则 ESP8266 Station 接⼝会在系统初始化完成后，⾃动连接 AP（路由），⽆需再调⽤ wifi_station_connect
	否则，需要调⽤ wifi_station_connect 连接 AP（路由）。
	会更新保存到 Flash 系统参数区。
*/
bool wifi_station_set_config(struct	station_config	*config){
	/*
	参数 
		配置参数指针
	返回
		true：成功
		false：失败
	*/
}
//示例
void ICACHE_FLASH_ATTR user_set_station_config(void){
   char ssid[32] = SSID;
   char password[64] = PASSWORD;
   struct station_config stationConf;
   
   stationConf.bssid_set = 0; //need not check MAC address of AP
   
   os_memcpy(&stationConf.ssid, ssid, 32);
   os_memcpy(&stationConf.password, password, 64);
   wifi_station_set_config(&stationConf);
}

void user_init(void){
   wifi_set_opmode(STATIONAP_MODE); //Set softAP + station mode
   user_set_station_config();
}


/*
	在 ESP8266 Station 使能的情况下，调⽤本接⼝。
	本设置如果与原设置不同，将更新保存到 Flash 系统参数区。
	因为 ESP8266 只有⼀个信道，因此 SoftAP+Station 共存模式时，ESP8266 SoftAP 接⼝会⾃动调节信道与 ESP8266 Station ⼀致，详细说明请参考附录。
*/
bool wifi_softap_set_config (struct softap_config *config){
	/*
	参数 
		配置参数
	返回
		true：成功
		false：失败
	*/
}
```
四、wifi_station_set_config_current（设置配置参数，不保存到 Flash）
wifi_softap_set_confifig_current
```c
/*
	请在使能的情况下，调⽤本接⼝。
	如果 user_init 中调⽤，则 ESP8266 Station 接⼝会在系统初始化完成后，⾃动连接 AP（路由），⽆需再调⽤ wifi_station_connect
	否则，需要调⽤ wifi_station_connect 连接 AP（路由）。
	会更新保存到 Flash 系统参数区。
*/
bool wifi_station_set_config_current(struct	station_config	*config){
	/*
	参数 
		配置参数指针
	返回
		true：成功
		false：失败
	*/
}

bool wifi_softap_set_config_current (struct softap_config *config)
```
五、wifi_station_connect（连接 AP）
```c
/*
	请勿在 user_init 中调⽤本接⼝，请在 ESP8266 Station 使能并初始化完成后调⽤；
	如果已连接某个 AP，请先调⽤ wifi_station_disconnect	断开上⼀次连接。
*/
bool wifi_station_connect (void){
	/*
		返回
			true：成功
			false：失败
	*/
}
```
六、wifi_station_get_connect_status(查询连接 AP 的状态)
```c
/*
	若为特殊应⽤场景：调⽤ wifi_station_set_reconnect_policy 关闭重连功能，且未调⽤wifi_set_event_handler_cb 注册 Wi-Fi 事件回调，则本接⼝失效，⽆法准确获得连接状态。
*/
uint8 wifi_station_get_connect_status(void){
	/*
		返回
		enum{
			STATION_IDLE = 0,
			STATION_CONNECTING,
			STATION_WRONG_PASSWORD,
			STATION_NO_AP_FOUND,
			STATION_CONNECT_FAIL,
			STATION_GOT_IP
		};
	*/
}
```
七、wifi_station_get_ap_info（获取保存的 AP 信息，最多记录 5 个。）
```c
uint8 wifi_station_get_ap_info(struct station_config config[]){
	/*
		参数 
			AP 的信息，数组⼤⼩必须为 5
		返回
			记录 AP 的数⽬
	*/
}


struct station_config config[5];
int i = wifi_station_get_ap_info(config);
```
八、wifi_station_dhcpc_stop（关闭 ESP8266 Station DHCP client）
```c
/*
	DHCP 默认开启。
	DHCP 与静态 IP 功能 wifi_set_ip_info 互相影响：
	DHCP 开启，则静态 IP 失效；设置静态 IP，则 DHCP 关闭。
*/
bool wifi_station_dhcpc_stop(void){
	/*
		返回
			true：成功
			false：失败
	*/
}
```
九、wifi_station_set_reconnect_policy（连接 AP 失败或断开后是否重连。默认重连。）
```c
/*
	建议在 user_init 中调⽤本接⼝
*/
bool wifi_station_set_reconnect_policy(bool	set){
	/*
		参数
			true：断开则重连
			false：断开不重连
		返回
			true：成功
			false：失败
	*/
}
```
十、wifi_softap_get_station_num（获取 ESP8266 SoftAP 下连接的 Station 个数）
```c
uint8 wifi_softap_get_station_num(void){
	/*
		 
		返回
			SoftAP 下连接的 Station 个数
	*/
}
```
一、wifi_get_ip_info（查询 Wi-Fi Station 接⼝或者 SoftAP 接⼝的 IP 地址）
```c
/*
	在 user_init 中，由于初始化尚未完成，⽆法通过本接⼝查询到有效 IP 地址。
	因为wifi配置是在内核中完成的，并不是一调用配置函数就完成此配置
*/
bool wifi_get_ip_info(uint8 if_index, struct ip_info *info){
	/*
		参数
			uint8 if_index：获取 Station 或者 SoftAP 接⼝的信息
				#define	STATION_IF	0x00
				#define	SOFTAP_IF 0x01
			struct	ip_info	*info：获取到的 IP 信息
		返回
			true：成功
			false：失败
	*/
}
```
二、wifi_set_ip_info（设置 Wi-Fi Station 接⼝或者 SoftAP 接⼝的 IP 地址）
```c
/*
	本接⼝设置静态 IP，请先关闭对应 DHCP 功能 wifi_station_dhcpc_stop 或者
wifi_softap_dhcps_stop
	设置静态 IP，则关闭 DHCP；DHCP 开启，则静态 IP 失效。
*/
bool wifi_set_ip_info(uint8 if_index, struct ip_info *info){
	/*
		参数
			uint8 if_index：获取 Station 或者 SoftAP 接⼝的信息
				#define	STATION_IF	0x00
				#define	SOFTAP_IF 0x01
			struct	ip_info	*info：获取到的 IP 信息
		返回
			true：成功
			false：失败
	*/
}
```

##### 示例
测试wifi.c
```c 
#include "./driver/wifi.h"

//WIFI AP模式初始化配置
void ICACHE_FLASH_ATTR WIFI_AP_Mode_Init(void){
    struct  softap_config AP_Config_Struct;
    wifi_set_opmode(0x02);      //配置WiFi为AP模式
    os_strcpy(AP_Config_Struct.ssid,WIFI_SSID);         //WiFi名称
    os_strcpy(AP_Config_Struct.password,WIFI_PASS);     //WiFi密码
    AP_Config_Struct.ssid_len=sizeof(WIFI_SSID);        //WiFi名称长度
    AP_Config_Struct.authmode=AUTH_WPA2_PSK;            //加密方式
    AP_Config_Struct.beacon_interval=100;               //信标间隔时间
    AP_Config_Struct.channel=1;                         //通道号
    AP_Config_Struct.max_connection=4;                  //允许最大连接设备数量
    AP_Config_Struct.ssid_hidden=0;                     //不隐藏WiFi
    wifi_softap_set_config(&AP_Config_Struct);
}

  

//WIFI STA模式初始化配置
void ICACHE_FLASH_ATTR WIFI_STA_Mode_Init(void){
    struct  station_config STA_Config_Struct;
    struct ip_info sta_ip_info;
    wifi_set_opmode(0x01);      //配置WiFi为STA模式
#if 0
    wifi_station_dhcpc_stop();  //关闭DHCP
    IP4_ADDR(&sta_ip_info.ip,192,168,43,189);       //设置 IP 地址
    IP4_ADDR(&sta_ip_info.gw,192,168,43,1);         //设置网关
    IP4_ADDR(&sta_ip_info.netmask,255,255,255,0);   //设置子网掩码
    wifi_set_ip_info(STATION_IF,&sta_ip_info);
#endif
    os_strcpy(STA_Config_Struct.ssid,WIFI_SSID);            //WiFi名称
    os_strcpy(STA_Config_Struct.password,WIFI_PASS);        //WiFi密码
    wifi_station_set_config(&STA_Config_Struct);
}

```
调用示例user_main.c
```c 
user_init(void){
	....
   WIFI_AP_Mode_Init();	//配置为AP模式
}
```

#### 10、WIFI(配套示例WIFI_AP/STA_UDP_XXX) 
**了解：**
```plaintext
UDP 
	发送方通过IP地址和端口号，发送给接收方。
	接收方从数据包里得到发送方的IP地址和端口号。
实验一：
	电脑作为客服端，ESP8266 作为服务端，客服端主动向服务器发送数据，服务器被动接收到数据，同时在服务器接收到客服端发来的数据之后向对应的客服端回应；

实验二：
	ESP8266 作为客服端，电脑作为服务端，客服端主动向服务器发送数据，服务器被动接收到数据，同时在服务器接收到客服端发来的数据之后向对应的客服端回应。


```

##### 基础熟记
	ESP8266 作为AP服务器
	1、包含头文件espconn.h
	2、创建 UDP 通讯
	3、通过无线网络发送数据
	4、查询某个 TCP 连接或者 UDP 传输的远端信息，此函数一般在接收成功的回调函数中调用。
	ESP8266 作为AP客户端
	1、包含头文件espconn.h
	2、创建 UDP 通讯
	3、通过无线网络接收数据
	4、查询某个 TCP 连接或者 UDP 传输的远端信息，此函数一般在接收成功的回调函数中调用。
	ESP8266 作为STA服务器
	1、跟ap相同步骤
	ESP8266 作为STA客户端
	1、跟ap相同步骤
```c
struct espconn {
 enum espconn_type type; //连接类型，可以是 UDP 和 TCP
 enum espconn_state state; //连接状态
 union {
 esp_tcp *tcp;
 esp_udp *udp;
 } proto; //一个共用体，包含了一个 tcp 连接参数结构体和 udp
//连接参数结构体
 espconn_recv_callback recv_callback; //接收成功的回调函数
 espconn_sent_callback sent_callback; //发送成功的回调函数
 uint8 link_cnt; //连接数量
 void *reverse; //指针变量，可用来存储相关需要的数据
};
//返回值：0：成功，其他：失败，返回对应的错误码
//ESPCONN_ ARG:未找到参数 espconn 对应的 UDP 连接
//ESPCONN_MEM:空间不足
//ESPCONN_ ISCONN:连接已经建立
//注意：定义的网络结构体必须是全局变量。


//创建 UDP 通讯
struct espconn ESPConnect_Struct; //定义网络连接结构体，全局变量
esp_udp udp_Struct;
ESPConnect_Struct.type=ESPCONN_UDP;
ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));
ESPConnect_Struct.proto.udp->local_port=9999;
ESPConnect_Struct.sent_callback=ESP8266_UDP_Sen d_Cb;
ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;
espconn_create(&ESPConnect_Struct);

//通过无线网络发送数据(结构体，数据，数据的长度)
espconn_send(&ESPConnect_Struct,"Hello, I'm esp8266!",os_strlen("Hello,I'm esp8266!"));

//查询某个 TCP 连接或者 UDP 传输的远端信息，此函数一般在接收成功的回调函数中调用。（结构体、IP、连接方式 0 正常server 1 SSL server）
sint8 espconn_get_connection_info(struct espconn *espconn, remot_info **pcon_info,uint8 typeflags)
```

```c
struct espconn ESPConnect_Struct; //定义网络连接结构体，全局变量
esp_udp udp_Struct;
ESPConnect_Struct.type=ESPCONN_UDP;
ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));
ESPConnect_Struct.proto.udp->local_port=9999;
ESPConnect_Struct.proto.udp->remote_port=6666;
ESPConnect_Struct.proto.udp->remote_ip[0]=192;
ESPConnect_Struct.proto.udp->remote_ip[1]=168;
ESPConnect_Struct.proto.udp->remote_ip[2]=4;
ESPConnect_Struct.proto.udp->remote_ip[3]=2;
ESPConnect_Struct.sent_callback=ESP8266_UDP_Sen d_Cb;
ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;
espconn_create(&ESPConnect_Struct);
```
##### UDP_AP示例
###### WIFI_AP_UDP_Sever
```c 
#include "./driver/wifi.h"
#include "espconn.h"
#include "./driver/Peripherals.h"
#include "mem.h"

//WIFI AP模式初始化配置
void ICACHE_FLASH_ATTR WIFI_AP_Mode_Init(void)
{
	struct	softap_config AP_Config_Struct;

	wifi_set_opmode(0x02);		//配置WiFi为AP模式

	os_strcpy(AP_Config_Struct.ssid,WIFI_SSID);			//WiFi名称
	os_strcpy(AP_Config_Struct.password,WIFI_PASS);		//WiFi密码
	AP_Config_Struct.ssid_len=sizeof(WIFI_SSID);		//WiFi名称长度
	AP_Config_Struct.authmode=AUTH_WPA2_PSK;			//加密方式
	AP_Config_Struct.beacon_interval=100;				//信标间隔时间
	AP_Config_Struct.channel=1;							//通道号
	AP_Config_Struct.max_connection=4;					//允许最大连接设备数量
	AP_Config_Struct.ssid_hidden=0;						//不隐藏WiFi

	wifi_softap_set_config(&AP_Config_Struct);
}

//ESP8266 UDP通讯接收成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Receive_Cb(void *arg, char *pdata, unsigned short len)
{
	struct	espconn	*pesp_conn=arg;
	remot_info *premot=NULL;	//定义远端信息结构体
	premot=(remot_info*)os_malloc(sizeof(remot_info));	//申请内存
	os_printf("ESP8266 Receive Data=%s\r\n",pdata);
	
	if(espconn_get_connection_info(pesp_conn,&premot,0)==0)	//获取远端设备信息
	{
		pesp_conn->proto.udp->remote_port=premot->remote_port;
		pesp_conn->proto.udp->remote_ip[0]=premot->remote_ip[0];
		pesp_conn->proto.udp->remote_ip[1]=premot->remote_ip[1];
		pesp_conn->proto.udp->remote_ip[2]=premot->remote_ip[2];
		pesp_conn->proto.udp->remote_ip[3]=premot->remote_ip[3];
}
//给远端设备回应//ESP8266 UDP通讯接收成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Receive_Cb(void *arg, char *pdata, unsigned short len)
{
	struct	espconn	*pesp_conn=arg;
	remot_info *premot=NULL;	//定义远端信息结构体
	premot=(remot_info*)os_malloc(sizeof(remot_info));	//申请内存
	os_printf("ESP8266 Receive Data=%s\r\n",pdata);
	if(espconn_get_connection_info(pesp_conn,&premot,0)==0)	//获取远端设备信息
	{
		pesp_conn->proto.udp->remote_port=premot->remote_port;
		pesp_conn->proto.udp->remote_ip[0]=premot->remote_ip[0];
		pesp_conn->proto.udp->remote_ip[1]=premot->remote_ip[1];
		pesp_conn->proto.udp->remote_ip[2]=premot->remote_ip[2];
		pesp_conn->proto.udp->remote_ip[3]=premot->remote_ip[3];

		//给远端设备回应
		espconn_send(pesp_conn,"ESP8266 Receive Success!\r\n",os_strlen("ESP8266 Receive Success!\r\n"));
	}

	os_free(premot);	//释放内存
}

//ESP8266 UDP通讯发送成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Send_Cb(void *arg)
{
	os_printf("ESP8266 Send Data OK!\r\n");
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;
//UDP通讯初始化
void ICACHE_FLASH_ATTR WIFI_UDP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_UDP;
	ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));	//申请内存
	ESPConnect_Struct.proto.udp->local_port=9999;			//设置本地端口
	ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;	//注册udp通讯接成功回调函数
	ESPConnect_Struct.sent_callback=ESP8266_UDP_Send_Cb;	//注册udp通讯发送成功回调函数

//	espconn_regist_recvcb(&ESPConnect_Struct,ESP8266_UDP_Receive_Cb);
//	espconn_regist_sentcb(&ESPConnect_Struct,ESP8266_UDP_Send_Cb);
	espconn_create(&ESPConnect_Struct);
}

		espconn_send(pesp_conn,"ESP8266 Receive Success!\r\n",os_strlen("ESP8266 Receive Success!\r\n"));
	}

	os_free(premot);	//释放内存
}

//ESP8266 UDP通讯发送成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Send_Cb(void *arg)
{
	os_printf("ESP8266 Send Data OK!\r\n");
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;
//UDP_Sever通讯初始化
void ICACHE_FLASH_ATTR WIFI_UDP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_UDP;
	ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));	//申请内存
	ESPConnect_Struct.proto.udp->local_port=9999;			//设置本地端口
	ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;	//注册udp通讯接成功回调函数
	ESPConnect_Struct.sent_callback=ESP8266_UDP_Send_Cb;	//注册udp通讯发送成功回调函数

//	espconn_regist_recvcb(&ESPConnect_Struct,ESP8266_UDP_Receive_Cb);
//	espconn_regist_sentcb(&ESPConnect_Struct,ESP8266_UDP_Send_Cb);
	espconn_create(&ESPConnect_Struct);
}
```
调用示例user_main.c
```c 
user_init(void){
	....
  WIFI_AP_Mode_Init();	//配置为AP模式
}
```
###### WIFI_AP_UDP_Client
```C
//UDP_Client通讯初始化
void ICACHE_FLASH_ATTR WIFI_UDP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_UDP;
	ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));	//申请内存
	ESPConnect_Struct.proto.udp->local_port=9999;			//设置本地端口
	ESPConnect_Struct.proto.udp->remote_port=6666;
	ESPConnect_Struct.proto.udp->remote_ip[0]=192;
	ESPConnect_Struct.proto.udp->remote_ip[1]=168;
	ESPConnect_Struct.proto.udp->remote_ip[2]=4;
	ESPConnect_Struct.proto.udp->remote_ip[3]=2;
	ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;	//注册udp通讯接成功回调函数
	ESPConnect_Struct.sent_callback=ESP8266_UDP_Send_Cb;	//注册udp通讯发送成功回调函数
	espconn_create(&ESPConnect_Struct);
	FM_ON();
	espconn_send(&ESPConnect_Struct,"ESP8266 Online!\r\n",os_strlen("ESP8266 Online!\r\n"));
}
```

##### UDP_STA示例
###### WIFI_STA_UDP_Sever
```c
//WIFI STA模式初始化配置
void ICACHE_FLASH_ATTR WIFI_STA_Mode_Init(void)
{
	struct	station_config STA_Config_Struct;
	struct ip_info sta_ip_info;
	wifi_set_opmode(0x01);		//配置WiFi为STA模式
	os_strcpy(STA_Config_Struct.ssid,WIFI_SSID);			//WiFi名称
	os_strcpy(STA_Config_Struct.password,WIFI_PASS);		//WiFi密码
	wifi_station_set_config(&STA_Config_Struct);
}

//ESP8266 UDP通讯接收成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Receive_Cb(void *arg, char *pdata, unsigned short len){
	struct	espconn	*pesp_conn=arg;
	remot_info *premot=NULL;	//定义远端信息结构体
	premot=(remot_info*)os_malloc(sizeof(remot_info));	//申请内存
	os_printf("ESP8266 Receive Data=%s\r\n",pdata);
	if(espconn_get_connection_info(pesp_conn,&premot,0)==0)	//获取远端设备信息
	{
		pesp_conn->proto.udp->remote_port=premot->remote_port;
		pesp_conn->proto.udp->remote_ip[0]=premot->remote_ip[0];
		pesp_conn->proto.udp->remote_ip[1]=premot->remote_ip[1];
		pesp_conn->proto.udp->remote_ip[2]=premot->remote_ip[2];
		pesp_conn->proto.udp->remote_ip[3]=premot->remote_ip[3];
		//给远端设备回应
		espconn_send(pesp_conn,"ESP8266 Receive Success!\r\n",os_strlen("ESP8266 Receive Success!\r\n"));
	}
	os_free(premot);	//释放内存
}

//ESP8266 UDP通讯发送成功回调函数
void ICACHE_FLASH_ATTR ESP8266_UDP_Send_Cb(void *arg)
{
	os_printf("ESP8266 Send Data OK!\r\n");
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;
//UDP通讯初始化
void ICACHE_FLASH_ATTR WIFI_UDP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_UDP;
	ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));//申请内存
	ESPConnect_Struct.proto.udp->local_port=9999;	//设置本地端口
	ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;	//注册udp通讯接成功回调函数
	ESPConnect_Struct.sent_callback=ESP8266_UDP_Send_Cb; //注册udp通讯发送成功回调函数
	espconn_create(&ESPConnect_Struct);
}
```
调用示例user_main.c
```C
void ICACHE_FLASH_ATTR user_init(void){
	 ...
	WIFI_STA_Mode_Init();	//配置为AP模式
}
```
###### WIFI_STA_UDP_Client
```C
//UDP通讯初始化
void ICACHE_FLASH_ATTR WIFI_UDP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_UDP;
	ESPConnect_Struct.proto.udp=(esp_udp*)os_malloc(sizeof(esp_udp));	//申请内存
	ESPConnect_Struct.proto.udp->local_port=9999;			//设置本地端口
	ESPConnect_Struct.proto.udp->remote_port=6666;
	ESPConnect_Struct.proto.udp->remote_ip[0]=192;
	ESPConnect_Struct.proto.udp->remote_ip[1]=168;
	ESPConnect_Struct.proto.udp->remote_ip[2]=0;
	ESPConnect_Struct.proto.udp->remote_ip[3]=6;
	ESPConnect_Struct.recv_callback=ESP8266_UDP_Receive_Cb;	//注册udp通讯接成功回调函数
	ESPConnect_Struct.sent_callback=ESP8266_UDP_Send_Cb;	//注册udp通讯发送成功回调函数
	espconn_create(&ESPConnect_Struct);
	espconn_send(&ESPConnect_Struct,"ESP8266 Online!\r\n",os_strlen("ESP8266 Online!\r\n"));
}
```

#### 11、WIFI(配套示例WIFI_AP/STA_TCP_XXX) 
##### 基础熟记
	ESP8266 作为STA服务器
	1、包含头文件espconn.h
	2、创建TCP server 建立侦听
	3、注册 ESP8266 TCP server 超时时间（原因超时无传输数据会断开）
	4、通过无线网络发送数据
	5、查询某个 TCP 连接或者 UDP 传输的远端信息
	ESP8266 作为STA客户端
	1、包含头文件espconn.h
	2、连接 TCP server（ESP8266 作为 TCP client）。
	3、通过无线网络发送数据
	
	ESP8266 作为AP服务器
	1、去连接 WiFi 热点网络（实际代码跟STA差不大多）
	ESP8266 作为AP客户端
	1、去连接 WiFi 热点网络（实际代码跟STA差不大多）
```c
struct espconn {
 enum espconn_type type; //连接类型，可以是 UDP 和 TCP
 enum espconn_state state; //连接状态
 union {
 esp_tcp *tcp;
 esp_udp *udp;
 } proto; //一个共用体，包含了一个 tcp 连接参数结构体和 udp
//连接参数结构体
 espconn_recv_callback recv_callback; //接收成功的回调函数
 espconn_sent_callback sent_callback; //发送成功的回调函数
 uint8 link_cnt; //连接数量
 void *reverse; //指针变量，可用来存储相关需要的数据
};
//返回值：0：成功，其他：失败，返回对应的错误码
//ESPCONN_ ARG:未找到参数 espconn 对应的 UDP 连接
//ESPCONN_MEM:空间不足
//ESPCONN_ ISCONN:连接已经建立
//注意：定义的网络结构体必须是全局变量。


//创建TCP server 建立侦听
struct espconn ESPConnect_Struct;//定义网络信息结构体，全局变量
ESPConnect_Struct.type=ESPCONN_TCP;
ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp)); //申请内存
ESPConnect_Struct.proto.tcp->local_port=6666;
ESPConnect_Struct.proto.tcp->connect_callback=WIFI_TCP_Connect_Success_Cb;
ESPConnect_Struct.proto.tcp->disconnect_callback=WIFI_TCP_Disconnect_Cb;
ESPConnect_Struct.proto.tcp->reconnect_callback=WIFI_TCP_Reconnect_Cb;
ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;
espconn_accept(&ESPConnect_Struct);

//注册 ESP8266 TCP server 超时时间（结构体、超时时间s， 当前设置对TCP连接有效 0全部，1仅自己）
espconn_regist_time(&ESPConnect_Struct,300,1);

//通过无线网络发送数据（结构体，发送的内容，内容的长度）
espconn_send(&ESPConnect_Struct,"Hello, I'm esp8266!",os_strlen("Hello, 
I'm esp8266!"));

//查询某个 TCP 连接或者 UDP 传输的远端信息，此函数一般在接收成功的回调函数中调用。（结构体、IP、连接方式 0 正常server 1 SSL server）
sint8 espconn_get_connection_info(struct espconn *espconn, remot_info **pcon_info,uint8 typeflags)
```

```c
//连接 TCP server（ESP8266 作为 TCP client）
struct espconn ESPConnect_Struct;//定义网络信息结构体，全局变量
ESPConnect_Struct.type=ESPCONN_TCP;
ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp)); //申请内存
ESPConnect_Struct.proto.tcp->remote_ip[0]=192;
ESPConnect_Struct.proto.tcp->remote_ip[1]=168;
ESPConnect_Struct.proto.tcp->remote_ip[2]=1;
ESPConnect_Struct.proto.tcp->remote_ip[3]=43;
ESPConnect_Struct.proto.tcp->connect_callback=WIFI_TCP_Connect_Success_Cb;
ESPConnect_Struct.proto.tcp->disconnect_callback=WIFI_TCP_Disconnect_Cb;
ESPConnect_Struct.proto.tcp->reconnect_callback=WIFI_TCP_Reconnect_Cb;
ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;
espconn_connect (&ESPConnect_Struct);truct;//定义网络信息结构体，全局变量

//通过无线网络发送数据
espconn_send(&ESPConnect_Struct,"Hello, I'm esp8266!",os_strlen("Hello, 
I'm esp8266!"));
```
##### TCP_STA示例
###### WIFI_STA_TCP_Sever
```c 
#include "./driver/wifi.h"
#include "espconn.h"
#include "mem.h"
#include "./driver/Peripherals.h"
//WIFI STA模式初始化配置
void ICACHE_FLASH_ATTR WIFI_STA_Mode_Init(void)
{
	struct	station_config STA_Config_Struct;
	struct ip_info sta_ip_info;
	wifi_set_opmode(0x01);		//配置WiFi为STA模式
	os_strcpy(STA_Config_Struct.ssid,WIFI_SSID);			//WiFi名称
	os_strcpy(STA_Config_Struct.password,WIFI_PASS);		//WiFi密码
	wifi_station_set_config(&STA_Config_Struct);
}
//ESP8266 TCP通讯接收成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Receive_Cb(void *arg, char *pdata, unsigned short len){
	struct	espconn	*pesp_conn=arg;
	os_printf("ESP8266 Receive Data=%s\r\n",pdata);
	//给远端设备回应
	espconn_send(pesp_conn,"ESP8266 Receive Success!\r\n",os_strlen("ESP8266 Receive Success!\r\n"));
}

//TCP连接成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Connect_Success_Cb(void *arg)
{
	os_printf("ESP8266 TCP Connect Success!\r\n");
}

//TCP正常断开回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Disconnect_Cb(void *arg)
{
	os_printf("ESP8266 TCP Disconnect Success!\r\n");
}

//TCP异常断开的回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Reconnect_Cb(void *arg, sint8 err)
{
	switch(err)	//输出错误信息
	{
	case ESPCONN_TIMEOUT:
		os_printf("ESPCONN_TIMEOUT!\r\n");break;
	case ESPCONN_ABRT:
		os_printf("ESPCONN_ABRT!\r\n");break;
	case ESPCONN_RST:
		os_printf("ESPCONN_RST!\r\n");break;
	case ESPCONN_CLSD:
		os_printf("ESPCONN_CLSD!\r\n");break;
	case ESPCONN_CONN:
		os_printf("ESPCONN_CONN!\r\n");break;
	case ESPCONN_HANDSHAKE:
		os_printf("ESPCONN_HANDSHAKE!\r\n");break;
	default:
		os_printf("ESPCONN_PROTO_MSG!\r\n");break;
	}

	//需要重新建立TCP连接
	espconn_accept(&ESPConnect_Struct);	//建立TCP侦听
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;

void ICACHE_FLASH_ATTR WIFI_TCP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_TCP;
	ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp));	//申请内存
	ESPConnect_Struct.proto.tcp->local_port=9999;
	ESPConnect_Struct.proto.tcp->connect_callback=ESP8266_TCP_Connect_Success_Cb;	//TCP连接成功回调函数
	ESPConnect_Struct.proto.tcp->disconnect_callback=ESP8266_TCP_Disconnect_Cb;		//TCP正常断开回调函数
	ESPConnect_Struct.proto.tcp->reconnect_callback=ESP8266_TCP_Reconnect_Cb;		//TCP异常断开回调函数

	ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
	ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;

	espconn_accept(&ESPConnect_Struct);	//建立TCP侦听
	espconn_regist_time(&ESPConnect_Struct,10,0);	//设置超时时间
}


```
调用示例user_main.c
```c 
user_init(void){
	....
	WIFI_STA_Mode_Init();	//配置为STA模式
}
```
###### WIFI_STA_TCP_Client
```C
#include "./driver/os_timer.h"
//ESP8266 TCP通讯发送成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Send_Cb(void *arg)
{
	os_printf("ESP8266 Send Data OK!\r\n");
}

//TCP连接成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Connect_Success_Cb(void *arg)
{
	os_timer_disarm(&os_timer_tcp);			//关闭TCP连接定时器
	os_printf("ESP8266 TCP Connect Success!\r\n");
}
//TCP异常断开的回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Reconnect_Cb(void *arg, sint8 err)
{
	switch(err)	//输出错误信息
	{
	case ESPCONN_TIMEOUT:
		os_printf("ESPCONN_TIMEOUT!\r\n");break;
	case ESPCONN_ABRT:
		os_printf("ESPCONN_ABRT!\r\n");break;
	case ESPCONN_RST:
		os_printf("ESPCONN_RST!\r\n");break;
	case ESPCONN_CLSD:
		os_printf("ESPCONN_CLSD!\r\n");break;
	case ESPCONN_CONN:
		os_printf("ESPCONN_CONN!\r\n");break;
	case ESPCONN_HANDSHAKE:
		os_printf("ESPCONN_HANDSHAKE!\r\n");break;
	default:
		os_printf("ESPCONN_PROTO_MSG!\r\n");break;
	}

	//需要重新建立TCP连接
	os_timer_arm(&os_timer_tcp,1000,1);		//重新打开TCP连接定时器
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;

void ICACHE_FLASH_ATTR WIFI_TCP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_TCP;
	ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp));	//申请内存
	ESPConnect_Struct.proto.tcp->remote_port=8888;
	ESPConnect_Struct.proto.tcp->remote_ip[0]=192;
	ESPConnect_Struct.proto.tcp->remote_ip[1]=168;
	ESPConnect_Struct.proto.tcp->remote_ip[2]=0;
	ESPConnect_Struct.proto.tcp->remote_ip[3]=6;
	ESPConnect_Struct.proto.tcp->connect_callback=ESP8266_TCP_Connect_Success_Cb;	//TCP连接成功回调函数
	ESPConnect_Struct.proto.tcp->disconnect_callback=ESP8266_TCP_Disconnect_Cb;		//TCP正常断开回调函数
	ESPConnect_Struct.proto.tcp->reconnect_callback=ESP8266_TCP_Reconnect_Cb;		//TCP异常断开回调函数

	ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
	ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;

	espconn_connect(&ESPConnect_Struct);	//连接TCP Server
}
```

##### TCP_AP示例
###### WIFI_AP_TCP_Sever
```c
#include "./driver/wifi.h"
#include "espconn.h"
#include "./driver/Peripherals.h"
#include "mem.h"

//WIFI AP模式初始化配置
void ICACHE_FLASH_ATTR WIFI_AP_Mode_Init(void)
{
	struct	softap_config AP_Config_Struct;

	wifi_set_opmode(0x02);		//配置WiFi为AP模式

	os_strcpy(AP_Config_Struct.ssid,WIFI_SSID);			//WiFi名称
	os_strcpy(AP_Config_Struct.password,WIFI_PASS);		//WiFi密码
	AP_Config_Struct.ssid_len=sizeof(WIFI_SSID);		//WiFi名称长度
	AP_Config_Struct.authmode=AUTH_WPA2_PSK;			//加密方式
	AP_Config_Struct.beacon_interval=100;				//信标间隔时间
	AP_Config_Struct.channel=1;							//通道号
	AP_Config_Struct.max_connection=4;					//允许最大连接设备数量
	AP_Config_Struct.ssid_hidden=0;						//不隐藏WiFi

	wifi_softap_set_config(&AP_Config_Struct);
}
//ESP8266 TCP通讯接收成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Receive_Cb(void *arg, char *pdata, unsigned short len){
	struct	espconn	*pesp_conn=arg;
	os_printf("ESP8266 Receive Data=%s\r\n",pdata);
	//给远端设备回应
	espconn_send(pesp_conn,"ESP8266 Receive Success!\r\n",os_strlen("ESP8266 Receive Success!\r\n"));
}

//TCP连接成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Connect_Success_Cb(void *arg)
{
	os_printf("ESP8266 TCP Connect Success!\r\n");
}

//TCP正常断开回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Disconnect_Cb(void *arg)
{
	os_printf("ESP8266 TCP Disconnect Success!\r\n");
}

//TCP异常断开的回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Reconnect_Cb(void *arg, sint8 err)
{
	switch(err)	//输出错误信息
	{
	case ESPCONN_TIMEOUT:
		os_printf("ESPCONN_TIMEOUT!\r\n");break;
	case ESPCONN_ABRT:
		os_printf("ESPCONN_ABRT!\r\n");break;
	case ESPCONN_RST:
		os_printf("ESPCONN_RST!\r\n");break;
	case ESPCONN_CLSD:
		os_printf("ESPCONN_CLSD!\r\n");break;
	case ESPCONN_CONN:
		os_printf("ESPCONN_CONN!\r\n");break;
	case ESPCONN_HANDSHAKE:
		os_printf("ESPCONN_HANDSHAKE!\r\n");break;
	default:
		os_printf("ESPCONN_PROTO_MSG!\r\n");break;
	}

	//需要重新建立TCP连接
	espconn_accept(&ESPConnect_Struct);	//建立TCP侦听
}


//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;
void ICACHE_FLASH_ATTR WIFI_TCP_Init(void){
	ESPConnect_Struct.type=ESPCONN_TCP;
	ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp));	//申请内存
	ESPConnect_Struct.proto.tcp->local_port=9999;
	ESPConnect_Struct.proto.tcp->connect_callback=ESP8266_TCP_Connect_Success_Cb;	//TCP连接成功回调函数
	ESPConnect_Struct.proto.tcp->disconnect_callback=ESP8266_TCP_Disconnect_Cb;		//TCP正常断开回调函数
	ESPConnect_Struct.proto.tcp->reconnect_callback=ESP8266_TCP_Reconnect_Cb;		//TCP异常断开回调函数

	ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
	ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;

	espconn_accept(&ESPConnect_Struct);	//建立TCP侦听
	espconn_regist_time(&ESPConnect_Struct,10,0);	//设置超时时间
}
```
调用示例user_main.c
```C
void ICACHE_FLASH_ATTR user_init(void){
	 ...
	WIFI_AP_Mode_Init();	//配置为AP模式
}
```
###### WIFI_AP_TCP_Client
```C
#include "./driver/os_timer.h"

//ESP8266 TCP通讯发送成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Send_Cb(void *arg)
{
	os_printf("ESP8266 Send Data OK!\r\n");
}

//TCP连接成功回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Connect_Success_Cb(void *arg)
{
	os_timer_disarm(&os_timer_tcp);			//关闭TCP连接定时器
	os_printf("ESP8266 TCP Connect Success!\r\n");
}

//TCP异常断开的回调函数
void ICACHE_FLASH_ATTR ESP8266_TCP_Reconnect_Cb(void *arg, sint8 err)
{
	switch(err)	//输出错误信息
	{
	case ESPCONN_TIMEOUT:
		os_printf("ESPCONN_TIMEOUT!\r\n");break;
	case ESPCONN_ABRT:
		os_printf("ESPCONN_ABRT!\r\n");break;
	case ESPCONN_RST:
		os_printf("ESPCONN_RST!\r\n");break;
	case ESPCONN_CLSD:
		os_printf("ESPCONN_CLSD!\r\n");break;
	case ESPCONN_CONN:
		os_printf("ESPCONN_CONN!\r\n");break;
	case ESPCONN_HANDSHAKE:
		os_printf("ESPCONN_HANDSHAKE!\r\n");break;
	default:
		os_printf("ESPCONN_PROTO_MSG!\r\n");break;
	}

	//需要重新建立TCP连接
	os_timer_arm(&os_timer_tcp,1000,1);		//重新打开TCP连接定时器
}

//定义网络信息结构体	全局变量
struct	espconn ESPConnect_Struct;

void ICACHE_FLASH_ATTR WIFI_TCP_Init(void)
{
	ESPConnect_Struct.type=ESPCONN_TCP;
	ESPConnect_Struct.proto.tcp=(esp_tcp*)os_malloc(sizeof(esp_tcp));	//申请内存
	ESPConnect_Struct.proto.tcp->remote_port=8888;
	ESPConnect_Struct.proto.tcp->remote_ip[0]=192;
	ESPConnect_Struct.proto.tcp->remote_ip[1]=168;
	ESPConnect_Struct.proto.tcp->remote_ip[2]=4;
	ESPConnect_Struct.proto.tcp->remote_ip[3]=2;
	ESPConnect_Struct.proto.tcp->connect_callback=ESP8266_TCP_Connect_Success_Cb;	//TCP连接成功回调函数
	ESPConnect_Struct.proto.tcp->disconnect_callback=ESP8266_TCP_Disconnect_Cb;		//TCP正常断开回调函数
	ESPConnect_Struct.proto.tcp->reconnect_callback=ESP8266_TCP_Reconnect_Cb;		//TCP异常断开回调函数

	ESPConnect_Struct.recv_callback=ESP8266_TCP_Receive_Cb;
	ESPConnect_Struct.sent_callback=ESP8266_TCP_Send_Cb;

	espconn_connect(&ESPConnect_Struct);	//连接TCP Server
}
```

