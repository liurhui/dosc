
---
创建日期:
  -  2022/11/14
---
## 搭建环境

不再安装1.0了 太麻烦了，前期设置开发环境浪费时间。
教程以0.5为入门 然后 3.0用1.5版本。
https://www.bilibili.com/video/BV1h64y1c78u?p=4&vd_source=8c250cc458d476b5cdce2e6ed0343a02
https://item.taobao.com/item.htm?spm=a1z0d.7625083.1998302264.6.5c5f4e69Ad5Pu5&id=640178869939

#### 软件下载说明   qq群号 :434878850  (AI-物联网全栈开发之旅)
	1、eclipes 其实下载了没有用，IDE已经自带了。估计是0.5版本需要。
	2、编译链工具 主要是 linux 平台要用所以要整理，win的在IDE里基本都给了压缩包。
	3、官方给的文件很散，还没网友整理的整齐。
	4、半颗心脏的教程图不对文（很难参照），但是基本上流程是对的。所以不一定得按半颗心脏的文档去操作，可以看下别的网友的。
	5、编译链文件是需要去配环境变量的，所以得手动根据版本进行替换bin路径。

##### eclipes for c/c++ 2019版本： 公众号 徐宏blog(半颗心脏)
	https://pan.baidu.com/s/1Eqg0nu_fHSIVTwiFvLLijA
	提取码：fqt7 
##### AThinkerIDE （b站网友提供的心脏的失效了）
https://www.bilibili.com/read/cv7760529/
	 https://pan.baidu.com/s/1Fu1Fen68SPfp0qzLvoxRRg 
	 提取码: nsmn
	 配置：https://docs.ai-thinker.com/ai_ide_install?s[]=aithinkeride
##### cywin window： 都在 AThinkerIDE 包里
	根据 AThinkerIDE_V1.0版本自带或分离出来单独安装

##### 2.0和3.0SDK 官方下载地址  包含了AThinkerIDE0.5版本的编译链
https://github.com/espressif/ESP8266_RTOS_SDK
##### AThinkerIDE0.5版本的编译链下载（点击立即下载）
	https://dl.espressif.com/dl/xtensa-lx106-elf-win32-1.22.0-88-gde0bdc1-4.8.5.tar.gz
 
#### AiThinkerIDE_V0.5配置环境变量
	自己创建 Espressif\IDE  把两个都放进去 然后去加环境变量
 编辑环境变量选：系统变量 -> Path 新增 
 `C:\Espressif\IDE\AiThinkerIDE_V0.5\cygwin\bin`
 `C:\Espressif\IDE\xtensa-lx106-elf\bin`
 
#### eclipes 安装（代码用这个编写） 
	压缩包解压后是免安装的  配个项目存储位置后，根据文档去配置依赖。
	
#### 串口调试工具aithinker_serial_tool
https://docs.ai-thinker.com/_media/tools/aithinker_serial_tool_v1.2.3.7z

#### 安信可 开发工具手册集合（Ai-ThinkerIDE_V1.5）
https://docs.ai-thinker.com/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B72

### 烧录工具
https://docs.ai-thinker.com/_media/flash_download_tool_v3.8.5_1.zip
参照blog
https://blog.csdn.net/qq_26043945/article/details/124623326

如果出现无法烧写  GPIO0 先通过接地一会放电后 然后板子上电（灯会闪烁一下），再点击开始下载 。至于com 口先上一次电记录下。
	黑色的板要插电池，白色的不用。原因未知，这里利用了水墨屏的PCB刚好有8266的外围基础电路。所以可以省去买8266开发板。
	
#### 烧录技巧  分两种得看编译后的bin。根据SDK版本。
	1、带boot.bin的  2、不带boot.bin的
	3、0x3fe000、0x3fc000、0x00000  地址基本固定，剩余一个地址基本得看编译后 编辑器IDE面板的显示。
##### 像这样的 就是 user1.4096.new.6.bin 在  upgrade目录下。且地址0x01000
```plaintext
!!!
Support boot_v1.4 and +
Generate user1.4096.new.6.bin successully in folder bin/upgrade.
boot.bin------------>0x00000
user1.4096.new.6.bin--->0x01000
!!!
make[1]: Leaving directory '/cygdrive/c/Users/81839/Desktop/github/StudyInEsp8266/3_TimerLED/app'
```
##### 不带boot.bin
烧录文件     烧录地址
blank.bin        0x3fe000
esp_init_data_default.bin        0x3fc000
eagle.flash.bin        0x00000
eagle.irom0text.bin         0x40000

##### 带boot.bin
烧录文件   烧录地址
blank.bin    0x3fe000
esp_init_data_default.bin   0x3fc000
boot.bin    0x00000
user1.4096.new.6.bin    0x01000

#### ESP8266 DOWNLOAD TOOL V3.8.5 下载器选值
	8266-12系列的，是32Mbit，也就是4M flash ,所以他们的地址分别是 0x3FC000 和 0x3FE000 , 最后2个的烧录文件地址看编译之后结果而决定！
	四根线就是`QIO`，而`DIO`就是六根线，至于后面还有`QOUT`和`DOUT`和`flash`芯片有关，平时最多的是`DIO`或者是`QIO`！
	
	https://blog.csdn.net/wowocpp/article/details/81368635  可以看下flash
	
![[ESP8266下载器.PNG]]
![[ESP8266下载器下载完成.PNG]]

#### 串口工具 （波特率 74880）


### IDE问题集
#### 当make clean 时一直报Error: Cannot run program "make": xxxxx  出现PATH:{xxxxxxxx;xxxxxx;xxx}把你的环境变量的内容都打印出来。
```plaintext
缘由：
	记录一下，当正常使用中把1.5 改回1后又改回1.5 。
	
经过实验：
	一直以为是环境变量没改对。但是发现怎么改都无效。最后 把 IDE 存储的工作组文件夹eclipse-workspace 给全删了。发现正常了。
	
总结原因：
	注意是因为把IDE 提示的是否打开改工作区的提示框禁掉了。导致重装时候也不会提示需要把工作区删了。再从C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse 打开eclipse.exe  桌面的那个exe 一般还是从原本的工作区进入，是个bug即使删除了原本的工作区他还会重新生成莫明奇妙。
	
```

#### 当程序没问题前提下，Cygwin GCC 方式导入 build时报什么xtensa-lx106-elf 类似这样的内容的错误，只会是你没有配置Environment 的  CYGWIN_HOME 的value 即 cygwin的路径
```plaintext
总结原因:
	cygwin在你所安装的IDE的目录下如：
		C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cygwin
```


#### Makefile 错误即环境变量问题，编译链替换：
```plaintext
https://blog.csdn.net/m0_50458807/article/details/114915004
添加快捷键配置环境和下载程序
https://blog.csdn.net/weixin_39676479/article/details/119882794?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119882794-blog-77985541.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-119882794-blog-77985541.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1
```

## 实践篇初学记录下流程
IDE 路径`C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse\eclipse.exe`
### Ai-ThinkerIDE_V1.5 编译 3.0/2.1.x/2.2.x  SDK版本
	1、图文教程
	https://aithinker.blog.csdn.net/article/details/106229281   
	2、B友视频示例（没啥好看的操作贼拉跨速度极慢，当失败太多怀疑人生时候看下怎么操作。）
	https://www.bilibili.com/video/av714622779/?vd_source=8c250cc458d476b5cdce2e6ed0343a02
	3、当bulid时，报 xtensa-lx106-elf-gcc 错误时
		就是esp8266 的环境变量配成了v5.2.0_for_3.0\xtensa-lx106-elf\bin 。 

```plaintext
环境变量只要这4个 其余的得删掉
esp8266 是v5.2.0_for_3.0\bin 。 esp32是xtensa-esp32-elf-5.0\bin 。

	
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\mingw32\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp32\xtensa-esp32-elf-5.0\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp8266\v5.2.0_for_3.0\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\usr\bin
 
```
#### 准备工作
	随Ai-ThinkerIDE_V1.5一起的两个依赖文件。v4.8.2_for_2.0.zip 和 plugin_cygwin.zip
根据环境变量看出 放到Ai-ThinkerIDE_V1.5相对的文件内。
#### 导入时工作 
	1、导入项目 选择 File→Import ，下面步骤：
	2、点开C/C++分支，并选中Existing Code as Makefile Project：
	3、取消C++的勾选，选中 Cross Gcc，点击Browser，选中我们解压后所在的目录。点击finish。

#### 导入后工作（make 以ESP-12F为例）
	1、Properties --> C/C++ Build --> Build command 中添加编译规则 make COMPILE=gcc BOOT=new APP=1 SPI_SPEED=40 SPI_MODE=DIO SPI_SIZE_MAP=6
	2、在Properties --> C/C++ Build --> Build directory 选择编译的工程路径，比如根目录下的 IoT_Demo工程。
	3、 先Clean Project ，后Build Project 。如果Build Project是灰色的，点击一下代码窗口空白处，就不会灰的了。很可能是你之前build运行了其他项目。这样反正我是成功了。

#### 示例项目
	git clone https://gitee.com/xuhongv/ESP8266_NONOS_SDK
	1.手动删除根目录下的`driver_lib`和 `third_party`这2个文件夹;
	2.把 `ESP8266_NONOS_SDK\examples` 内的 `IoT_Demo` 复制到 `ESP8266_NONOS_SDK`
	3.然后再进行 导入。 



### Ai-ThinkerIDE_V1.5 编译 2.0 SDK
	1、图文教程
	https://blog.csdn.net/weixin_56657463/article/details/124778792
	https://aithinker.blog.csdn.net/article/details/106229281
	2、当bulid时，报 xtensa-lx106-elf-gcc 错误时，就是IDE的Environment没配置 cygwin 路径。
```plaintext
环境变量只要这3个 其余的得删掉
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\usr\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cywin\bin
C:\Program Files (x86)\AiThinkerIDE_V1.5.2\msys32\opt\esp8266\v4.8.2_for_2.0\bin
```
#### 准备工作
	随Ai-ThinkerIDE_V1.5一起的两个依赖文件。v4.8.2_for_2.0.zip 和 plugin_cygwin.zip
根据环境变量看出 放到Ai-ThinkerIDE_V1.5相对的文件内。
#### 导入时工作
	1、导入项目 选择 File→Import ，下面步骤：
	2、点开C/C++分支，并选中Existing Code as Makefile Project：
	3、取消C++的勾选，选中 Cygwin GCC，点击Browser，选中我们解压后所在的目录。点击finish。

#### 导入后工作
	1、make COMPILE=gcc BOOT=new APP=1 SPI_SPEED=40 SPI_MODE=DIO SPI_SIZE_MAP=6
	2、查看Environment 的  CYGWIN_HOME  的 value 把  cygwin 路径填入
	 `C:\Program Files (x86)\AiThinkerIDE_V1.5.2\plugin_cygwin`然后点apply ，后点确认。 
	3、 先Clean Project ，后Build Project 。如果Build Project是灰色的，点击一下代码窗口空白处，就不会灰的了。很可能是你之前build运行了其他项目。这样反正我是成功了。
	
#### 示例项目 （以半颗心脏的git 2.0的代码示例集合）
	git clone https://github.com/xuhongv/StudyInEsp8266.git
	1. 直接按导入去操作就好，代码没问题的。






---
记录日期:
  -  2022/11/17
---

## 开始学习示例
打开 IDE `C:\Program Files (x86)\AiThinkerIDE_V1.5.2\eclipse\eclipse.exe`

https://blog.csdn.net/xh870189248/article/details/78155357  可以跑电路和代码没问题
以2.0SDK 来配置导入项目流程

### 8266-12F
地址范围  `0x000 000 - 0x3ff fff `        每个扇区 `4kb  =1024*4`
扇区范围    `3ff fff /1024/4  = 4 194 303 /1024/4 = 16383  =3ff `
所以扇区范围是  `0x000 - 0x3FF`

### 分为  FOTA支持云端升级，和non-FOTA不支持云端升级
![[ESP8266的bin说明.PNG]]
![[ESP8266的bin说明NON-FOTA.PNG]]
blank.bin        0x3fb000  // 貌似之前都没弄这个也行
blank.bin        0x3fe000
esp_init_data_default_v8.bin        0x3fc000
eagle.flash.bin        0x00000   // 看编译后的输出显示
eagle.irom0text.bin         0x10000    // 看编译后的输出显示
26M   40MHZ   DOUT    32Mbit     1152000


### ESP8266-12F 烧录 得按RST 才会读取gpio （没自动下载电路才要）
 先按住 BOOT 再按住RST  再松开RST  再松开BOOT 。下载完再按下RST。
原因是看规格书
因为开发板的GPIO0是 接 BOOT 按钮  ，复位应该是让恢复回默认高
![[ESP8266的开发板bin烧录说明.PNG]]



### 开发指南
	区别与 51 就是 不是通过 while(1)  用中断去触发具体时间去反复执行。
	ESP8266是基于内核回调。
#### 大致主体函数
1、应用函数:必须由另一个函数调用才会执行
```c
void user_init(void) { 
	// 初始化相关的参数和外设等
	// 初始化(需要用到哪些功能就进行相关配置,打开一个开关)
	// 他这里只是预编译后 相当于发送给内核指令， 进入内核处理 。
}
```
 **2、3、4 CPU通过发送的令内部去处理(正因如此,所以問单)**
2、中断通数:发生硬件中断时会调用这疾通数
```c
void xxxx_interrupt() { //如果有中断的话进行中断处理
//.....中断处理
}
```

3、回调函数:当某系统事件发生时,相点的国调通数由 non-OS SDK内核调用执行
```c
void xxx_Cb(){//如果有回调通数的话就进入回调两数
//....中新处理
}
```

4、任务函数:系统空闲的时候执行
```c
void xxx_task(){//如果有任务的话进入任务通数
//中断处理
}
```
#### 函数名规则
应用函数前面加 ICACHE_FLASH_ATTR 宏  和IRAM_ATTR宏
 ICACHE_FLASH_ATTR ： 放flash  比 iRAM 慢  但空间大
 IRAM_ATTR： 放 iRAM  速度快， 但空间小
相当于一个是存储芯片 一个是内存芯片

#### SDK  相当于提供API 可对内核的修改或设置
	如收发数据、TCP功能  硬件接口。也就是说隔绝了对底层硬件驱动库的操作。只要往对应的功能里面去发和收 实现 。根本不需要去关心 wifi是怎么实现的 只要往对应的api去发送相对格式的数据就好。那些库很多是不开源的没必要去看。
	需要的是进行 硬件初始化、定时器初始化 让定时器去触发具体的业务。
#### 注意
**ESP8266_NONOS_SDK_V1.5.2  - v2.2.1 之间的版本，需要 再user_main.c  手动加函数**
	千万不要管这些是干嘛的太深入了没必要。能跑就行 又不开源又不给说明。
```c
 void ICACHE_FLASH_ATTR user_rf_pre_init(void){
	 //配置ESP8266的射频参数
	if(!system_partition_table_regist(at_partition_table, sizeof(at_partition_table)/sizeof(at_partition_table[0]),SPI_FLASH_SIZE_MAP)) {
		os_printf("system_partition_table_regist fail\r\n");
		while(1);
	}
 }
 void ICACHE_FLASH_ATTR unit32 user_rf_cal_sector_set(void){
	 // 配置ESP8266的校准信息
	enum flash_size_map size_map = system_get_flash_size_map();
    uint32 rf_cal_sec = 0;
    switch (size_map) {
        case FLASH_SIZE_4M_MAP_256_256:rf_cal_sec = 128 - 5;
            break;
        case FLASH_SIZE_8M_MAP_512_512:rf_cal_sec = 256 - 5;
            break;
        case FLASH_SIZE_16M_MAP_512_512:rf_cal_sec = 512 - 5;
            break;
        case FLASH_SIZE_16M_MAP_1024_1024:rf_cal_sec = 512 - 5;
            break;
        case FLASH_SIZE_32M_MAP_512_512:rf_cal_sec = 1024 - 5;
            break;
        case FLASH_SIZE_32M_MAP_1024_1024:rf_cal_sec = 1024 - 5;
            break;
        case FLASH_SIZE_64M_MAP_1024_1024:rf_cal_sec = 2048 - 5;
            break;
        case FLASH_SIZE_128M_MAP_1024_1024:rf_cal_sec = 4096 - 5;
            break;
        default:
            rf_cal_sec = 0;
            break;
    }
    return rf_cal_sec;
 }
```

#### 1、GPIO(配套示例GPIO_Input)
##### 基础熟记
	ESP8266-12F 自身的那个小蓝色LED  的阴极是接在 GPIO2， 阳极是接VCC 。他受内核管控，即使操作了也会被内核给覆盖（也就是不要去操作他）。
	一、两个库 //没有库去官方的SDK内去拷贝来
```c
#include "eagle_soc.h"
#include  "gpio.h"

//像  uint32_t  这些都是在 c_types.h内定义的
//像 sint8_t 、 int8_t 、int8、 sint8 、s8 五种写法都是 signed char 的简写
//像 uint8 、uint8_t 、u8  三种写法都是 unsigned char
//而 
//像 32 带 t的都是 long    不带t 是int   注意坑
```
	二、设置管脚功能  //因为管脚可能有多个复用功能
```c
PIN_FUNC_SELECT(PIN_NAME,FUNC)  //引脚名字，管脚的功能

//加前缀 PERIPHS_IO_MUX_  如GPIO5  是MTDO_U  最终是 PERIPHS_IO_MUX_MTDO_U
//管脚作为普通IO口功能，查表是Function4，那么值需要-1就是3。
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,3);
//管脚作为I2SO_BCK功能，查表是Function2,那么值需要-1就是1。
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U,1);

或者参数二用加前缀的方式就不要去计算，如FUNC_GPIO12，可以直接进eagle_soc.h里面找 都定义在一块。
//gpio12脚, 功能是普通IO口
PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12)

```
	1、如GPIO15是MTDO_U , 
	2、然后去查表找到MTDO_U的那一行 ，目的是管脚是作为普通IO口还是复用功能，所对应的名称。
	
	
	![[ESP8266的GPIO对应的名称.PNG]]
	![[ESP8266的GPIO对应的名称查表.PNG]]
	
	三、管脚模式，管脚电平  
		尽量不用GPIO_OUTPUT_SET 有时候会有bug会收不到数据
```c
GPIO_OUTPUT_SET(gpio_no,bit_value) // 输入还是输出， 高电平还是低电平

//gpio2为输出模式输出低电平
// 固定写法 GPIO_ID_PIN(n)  n就是gpio引脚 
//  0是低电平  1是高电平
GPIO_OUTPUT_SET(GPIO_ID_PIN(2),0)
```

##### 常用的API
```c
#include "eagle_soc.h"
#include  "gpio.h"

//配置管脚
PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO2_U, FUNC_GPIO2);

//禁止管脚输出
GPIO_DIS_OUTPUT(GPIO_ID_PIN(12));

//禁止内部上拉
PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO2);
//使能内部上拉
PIN_PULLUP_EN(PERIPHS_IO_MUX_GPIO2);

//读取管脚电平状态
GPIO_INPUT_GET(GPIO_ID_PIN(12));
//输出管脚电平状态
GPIO_OUTPUT_SET(GPIO_ID_PIN(12), 0);

//喂狗
system_soft_wait_feed();

//GPIO口寄存器的读/写 函数  参数根据业务寄存器  
gpio_status= GPIO_REG_READ(GPIO_STATUS_ADDRESS);
GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status); 
```
外设初始化示例
```c
driver_lib/driver/Peripherals.c
//LED GPIO初始化
void LED_GPIO_Init (void)
{
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTDO_U, FUNC_GPIO15) ; //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (15), 0);//设置GPIO为输出模式 设置GPIO输出电平为高电平
}

//蜂鸣器GPIO初始化
void FM_GPIO_Init (void)
{
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12); //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (12), 0);//设置GPIO为输出模式设置GPIO输出电平为高电平
}

//继电器GPIO初始化
void RELAY_GPIO_Init (void)
{
PIN_FUNC_SELECT (PERIPHS_IO_MUX_MTCK_U, FUNC_GPIO13) ; //设置GPIO15管脚的功能GPIO
GPIO_OUTPUT_SET (GPIO_ID_PIN (13), 0) ;//设置GPIO为输出模式设置GPIO输出电平为高电平
}
```
使用示例
```c
void ICACHE FLASH ATTR 
user _init (void)
{
	LED_GPIO_Init (); //LED GPIO引脚初始化
	FM_GPIO_Init (); //蜂鸣器GPIO初始化
	RELAY_GPIO_Init(); //继电器GPIO初始化
	while (1)
		{
			system_soft_wdt_feed();//喂狗
			LED_ON();
			FM_ON();
			RELAY_ON();
			delay_ms (1000) ;
			system_soft_wdt_feed (); //喂狗
			LED_OFF();
			FM_OFF();
			RELAY_OFF();
			delay_ms (1000);
		}
}
```


#### 2、UART(配套示例UART)
	https://blog.csdn.net/springcity2014/article/details/83009665
##### 基础熟记
![[ESP8266的串口时序.PNG]]
**发送**： 低位前高位后 `bit0 ~ bit7`  顺序
**共10bit**  1起始 8bit 1停止，`11520个/秒 *10 = 115200bps`

**校验位**
	奇校验：10101001  则  凑1变成奇数个
	偶校验：10101001 则  凑1变成偶数个
	0校验 ：直接拼接0
	1校验 ：直接拼接1
	无校验则不加
	
**有校验位的数据包**：起始位，有效数据，校验位，停止位。
**屏蔽上电打印**
	没什么好办法只能改引脚，把上电默认的引脚改为别的引脚，串口工具只会去读默认引脚。
```c
// 举例
system_uart_swap(){
//U0TXD，U0RXD  改为对应U0RTS（MTDO/GPIO15），UOCTS(MTCK/GPIO13)
//烧录还走U0TXD 和 U0RXD
//GPIO15  对应RXD
//GPIO13  对应 TXD
}
```
##### 硬件
	esp8266-technical_reference_cn.pdf
	有两个分别是UART0 和 UART1，烧录默认用UART0。
	UART0 默认开启，UART1默认关闭。 
	ESP8266芯片本身支持26MHz 和40MHz 的晶振，若使用40MHz晶振，则默认波特率为115200，若使用26MHz晶振，则UART0上电后的波特率 = 26*115200/40 = 74880。
	安信可的ESP8266系列模组均使用26MHz，由于一般的串口工具不会支持这个波特率，所以上电时会有打印乱码。得用带有74880的串口助手
```plaintext
UART0: 既有发送引脚(TXD)也有接收引脚(RXD)
    U0TXD: pin26(U0TXD)
    U0RXD: pin25(U0RXD)
    U0CTS: pin12(MTCK)
    U0RTS: pin13(MTDO)
UART1:而 UART1 只有发送引脚(TXD)引脚为 GPIO2
    U1TXD: pin14(GPIO2)
```
##### 常用的API(通常main.c是这么去写)
	一、头文件
```c
//\driver_lib\driver\
uart.c
uart.h 
uart_register.h
```
	二、初始化
```c
//void uart_init(UartBautRate uart0_br, UartBautRate uart1_br)

uart_init(115200,115200);  //UART0波特率，UART1波特率
```
	三、发送字符串函数
```c
//uart0_sendStr("");  串口0的发送字符串函数
//uart1_sendStr_no_wait(""); 串口1的发送字符串函数
//前面加换行是避免别的数据没有换行 
uart0_sendStr("\r\n Hello Word! \r\n");
uart1_sendStr_no_wait("\r\n Hello Word! 1 \r\n");
```
	四、系统打印函数来打印串口写法
```c
//UART_SetPrintPort(uint8 uart_no)  UART号， UART0 或者 UART1

UART_SetPrintPort(UART1);
```

##### 串口API集(驱动uart.c用到的)
```c

//数据位
	#define UART_BIT_NUM 0x00000003 //数据位长度占用两个bit
	设置这两个bit可以配置数据长度0:5bit; 1:6bit；2:7bit；3:8bit
	#define UART_BIT_NUM_S    2     //寄存器偏移为2（第2bit开始）
void UART_SetWordLength(uint8 uart_no, UartBitsNum4Char len);

//停止位
	#define UART_STOP_BIT_NUM    0x00000003    //数据位长度占用两个bit
	设置这两个bit可以配置停止位长度 1:1bit；2:1.5bit；3:2bit
	#define UART_STOP_BIT_NUM_S    4    // 寄存器偏移为4(第4bit开始)
void UART_SetStopBits(uint8 uart_no, UartStopBitsNum bit_num);

//反相
    UART 各个信号输入与输出信号，可在内部进行反向配置
    #define UART_DTR_INV    （BIT(24)）
    #define UART_RTS_INV     (BIT(23))
    #define UART_TXD_INV     (BIT(22))
    #define UART_DSR_INV     (BIT(21))
    #define UART_CTS_INV     (BIT(20))
    #define UART_RXD_INV     (BIT(19))
    将对应寄存器置位，可以将对应信号线反向输出/输入。
void UART_SetLineInverse(uint8 uart_no, UART_LineLevelInverse inverse_mask);

//校验位
#define UART_PARITY_EN (BIT(1)) 校验使能：1：enable; 0：diable
#define UART_PARITY    (BIT(0)) 校验类型设置 1：奇校验；0：偶校验
void UART_SetParity(uint8 uart_no, UartParityMode Parity_mode);

//波特率 300 ~ 115200*40
void UART_SetBaudrate(uint8 uart_no,uint32 baud_rate);


//流量控制
    配置过程：
    a. 先配置uart0的pin12，pin13脚复用为U0CTS,和U0RTS功能。
    #define FUNC_U0RTS    4
    #define FUNC_U0CTS    4
    PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDO_U, FUNC_U0RTS);
    PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, FUNC_U0CTS);
    
    b. 接收方向的硬件流控可以配置阀值，当 rx fifo 中的长度大于所设的阀值， U0RTS脚就会拉高，阻
止对方发送。
    配置接收流控制阀：
    阀值相关的配置一般都在UART_CONF1定义的寄存器中
    #define UART_RX_FLOW_EN (BIT(23))  // 第23bit使能接收流控: 0:disable; 1:enable
    #define UART_RX_FLOW_THRHD 0x0000007F  // 门限值，占用7bit，范围0~127
    #define UART_RX_FLOW_THRHD_S    16   // 寄存器偏移为16 (第16bit开始)

    c. 发送方向的流控只需配置使能，该寄存器在UART_CONF0中：
    #define UART_TX_FLOW_EN    (BIT(15))   // 使能发送流控: 0:disable; 1:enable
void UART_SetFlowCtrl(uint8 uart_no,UART_HwFlowCtrl flow_ctrl,uint8 rx_thresh);

void UART_WaitTxFifoEmpty(uint8 uart_no , uint32 time_out_us); /*do not use if tx flow control enabled*/

void UART_ResetFifo(uint8 uart_no);

void UART_ClearIntrStatus(uint8 uart_no,uint32 clr_mask);

void UART_SetIntrEna(uint8 uart_no,uint32 ena_mask);

//切换打印函数输出端口
   默认情况下，系统打印函数 os_printf 从 uart0 口输出内容，通过以下接口可以设置从 uart0 或者 uart1 口输出打印。
void UART_SetPrintPort(uint8 uart_no);

bool UART_CheckOutputFinished(uint8 uart_no, uint32 time_out_us);
```
##### 还得配置串口中断（什么时候退出接收状态这部分在uart.c）
```plaintext
	由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数 UART_INT_ST(uart_no),软件可以在同一个中断服务函数里处理多个中断事件
(多个并列的if语句)。
```
**串口中断寄存器**
```plaintext
Uart 的中断寄存器有：
    UART_INT_RAW 中断原始状态寄存器
    UART_INT_ENA 中断使能寄存器：表示当前使能的uart中断
    UART_INT_ST 中断状态寄存器：表示当前有效的中断状态
    UART_INT_CLR 清除中断寄存器：置对应位来清除中断状态寄存器
 
接口
    打开中断使能：UART_ENABLE_INTR_MASK(uart_no, ena_mask)；
    关闭中断使能：UART_DISABLE_INTR_MASK(uart_no, disable_mask);
    清除中断状态：UART_CLR_INTR_STATUS_MASK(uart_no, clr_mask);
    获取中断状态：UART_GET_INTR_STATUS(uart_no);
```
**串口接收中过程会触发的三种中断**
**区别在于：**
		一个是手动分长度超过了长度则触发，人为设置阀值并且数据不会丢失。
		一个是自动但是超过了（系统）默认的最大长度，溢出中断触发则一般都会存在数据丢失。
		一个是开始接收数据后，长时间内没有接收到则表示结束接收。
**总结：**
	阈值、使能、清除状态。（即手动设置长度也叫full中断）
	溢出、使能、清除状态。（在没有配置阈值时候就用这个即自动溢出中断）
	超时、使能、清除状态。（也叫tout中断）
**一、full中断 (中断状态位：UART_RXFIFO_FULL_INT_ST)**
```plaintext
	说明：rx(接收)fifo数据比较长要用到，比如,配置阀值为100，并使能full中断，当串口收到100字节后，会触发full中断。
    
    1、配置 full中断阀值(或门限值)：(在UART_CONF1寄存器)
    #define UART_RXFIFO_FULL_THRHD    0x0000007F    // 门限值mask,7bit长,范围0-127
    #define UART_RXFIFO_FULL_THRHD_S  0    // 寄存器偏移为0 (第0bit开始)
    
    2、设置中断使能：(在UART_INT_ENA寄存器)
    #define UART_RXFIFO_FULL_INT_ENA  (BIT(0))    // full中断使能位，1:enable; 0:disable
    
    3、清除中断状态：
		对于full中断比较特殊，需要先将接收fifo中的数据全部读空，然后写清楚中断状态寄存器。否则推出后，中断状态位还是会被置上。
    
```
**二、溢出中断 (中断状态位：UART_RXFIFO_OVF_INT_ST)**
```plaintext
    说明：当接收队列的长度大于队列总长度(128bytes)时，会触发该中断信号。
    
    1、设置中断使能：(在UART_INT_ENA寄存器)
    #define UART_RXFIFO_OVF_INT_ENA    (BIT(4))    // 溢出中断使能位:1:enable; 0:disable
    
    2、清除中断状态：
	    读取队列值，使队列长度小于128，然后置清除中断状态寄存器即可。
```
**三、tout超时中断 (中断状态位：UART_RXFIFO_TOUT_INT_ST)**
```plaintext
    说明：当uart开始接收数据后，停止传输的时间超过所设定的门限值，就
会触发tout中断。
    1、配置tout中断阀值（或门限值）：(在UART_CONF1寄存器中)
    Tout阀值的单位为8个uart数据比特的时间(近似一个byte)
    #define UART_RX_TOUT_EN    (BIT(31))    // 超时功能使能位：1：enable；0：disable
    #define UART_RX_TOUT_THRHD 0x0000007F   // 超时阀值配置位，共7位，范围0-127
    #define UART_RX_TOUT_THRHD_S 24         // 寄存器偏移为24 (第24bit开始)
    
    2、设置中断使能：(在UART_INT_ENA寄存器)
    #define UART_RXFIFO_TOUT_INT_ENA    (BIT(8))  // tout中断使能位，1:enable;0:disable 
    
    3、清除中断状态：
	    与full中断类似，tout中断也需要先将接收fifo中的数据全部读空，然后写清除中断状态寄存器，否则退出后中断状态还是会被置上。
```

**四、full和tout 在uart.c   91行 是怎么配置寄存器的**
```C
//通过 WRITE_PERI_REG 给 uart0  配置UART_CONF1 寄存器 即 接收中断

//配置 full中断阀值100 
//7f & 100 =  0111 1111 &0110 0100 = 0110 0100     << 0   即值移动 0bit

//配置中断阀值
 WRITE_PERI_REG(
		 UART_CONF1(uart_no),
        ((100 & UART_RXFIFO_FULL_THRHD) << UART_RXFIFO_FULL_THRHD_S)|
        (0x02 & UART_RX_TOUT_THRHD) << UART_RX_TOUT_THRHD_S |
        UART_RX_TOUT_EN|
        ((0x10 & UART_TXFIFO_EMPTY_THRHD)<<UART_TXFIFO_EMPTY_THRHD_S));|
       SET_PERI_REG_MASK(UART_INT_ENA(uart_no), UART_RXFIFO_TOUT_INT_ENA |
       UART_FRM_ERR_INT_ENA
  );
 //清除状态
 WRITE_PERI_REG(UART_INT_CLR(uart_no), 0xffff);
 //使能中断
 SET_PERI_REG_MASK(
	 UART_INT_ENA(uart_no), 
	 UART_RXFIFO_FULL_INT_ENA|
	 UART_RXFIFO_OVF_INT_ENA
);

```


#### 3、GPIO中断（配套示例GPIO_EXIT在GPIO配置后配置GPIO中断）
	只有输入中断，没有输出中断。
	在中断服务函数内，不应该去写阻塞的逻辑（如延时）。
**参考文档：（p63）**
	手把手教你学ESP8266 NONOSDK开发指南——樱桃丸子单片机技术支持.pdf
	
##### 用到的相关的API
1、关闭 GPIO 中断
```c
ETS_GPIO_INTR_DISABLE()
```
2、配置 GPIO 中断触发的引脚
```c
void gpio_pin_intr_state_set( uint32 i, GPIO_INT_TYPE intr_state){
	//uint32 i: GPIO 引脚 ID
	/*
		typedef enum{
			GPIO_PIN_INTR_DISABLE= 0,//禁止中断
			GPIO_PIN_INTR_POSEDGE= 1,//上升沿触发
			GPIO_PIN_INTR_NEGEDGE= 2,//下降沿触发
			GPIO_PIN_INTR_ANYEDGE= 3,//双边沿触发
			GPIO_PIN_INTR_LOLEVEL= 4,//低电平触发
			GPIO_PIN_INTR_HILEVEL= 5//高电平触发
		} GPIO_INT_TYPE;
	*/
}


//例子：配置 GPIO14 引脚为下降沿触发。
gpio_pin_intr_state_set(GPIO_ID_PIN(14)，GPIO_PIN_INTR_NEGEDGE);
```
3、注册中断处理函数
```c
ETS_GPIO_INTR_ATTACH(func, arg){
	//Func:中断服务函数函数名
	//arg:传入的参数
}

```
4、打开 GPIO 中断
```c
ETS_GPIO_INTR_ENABLE()
```
5、读取 GPIO 中断标志位
```c
//用于存中断标志位，为了清除时候用
uint32 gpio_status;
// GPIO_STATUS_ADDRESS是 整个gpio口的状态寄存器
gpio_status= GPIO_REG_READ(GPIO_STATUS_ADDRESS);

```
6、清除 GPIO 中断标志位
```c
//清除中断标志位
GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);
```

##### GPIO中断示例(如GPIO5作为key,搭配个中断作为自动触发逻辑)
	这里以key.c 为demo   123是必须要的，34的内容根据实际业务去写，但基本有模板，加ICACHE_FLASH_ATTR 是目的存储起来。在key.h声明函数的时候不需要加前缀ICACHE_FLASH_ATTR否则报错（单片机通用知识）。在写业务时候可以用定义的宏也可以不用直接写对应的代码。是因为太浪费空间只用到一个宏的内容却引入整个.h。
	1、先初始化用作key的GPIO
	2、去初始化配置搭配的key的中断
	3、去定义key触发中断时的中断服务函数
	4、定义（封装起来复用）一些检测key的GPIO的一些逻辑代码
```c
#include "./driver/key.h"
#include "gpio.h"
#include <eagle_soc.h>
#include "./driver/Peripherals.h"

void ICACHE_FLASH_ATTR KEY_GPIO_Init(void){  //按键GPIO初始化
    PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U,FUNC_GPIO5);//设置GPIO5引脚的功能为GPIO
    GPIO_DIS_OUTPUT(GPIO_ID_PIN(5));  //设置GPIO为输入模式 禁止GPIO输出
    PIN_PULLUP_DIS(PERIPHS_IO_MUX_GPIO5_U); //禁止内部上拉
}
```

```c
//GPIO外部中断初始化
void ICACHE_FLASH_ATTR GPIO_EXIT_Init(void){
    KEY_GPIO_Init();  //配置相关GPIO为GPIO输入模式
    ETS_GPIO_INTR_DISABLE(); //关闭GPIO中断
    gpio_pin_intr_state_set(GPIO_ID_PIN(5), GPIO_PIN_INTR_NEGEDGE);  //配置GPIO触发引脚5和触发下降沿模式
    ETS_GPIO_INTR_ATTACH((ets_isr_t)GPIO_EXIT_Interrupt, NULL); //注册中断服务函数 GPIO_EXIT_Interrupt 函数名 没有传入参数为NULL
    ETS_GPIO_INTR_ENABLE(); //中断使能
}
```

```c
/*************************************************************************
 * FunctionName : GPIO外部中断中断服务函数
 * Description  : 主要是做按键检测到电平变化则认为是按下或松开按键，按下led亮松开灭。(之前demo是不用外部中断检测电平变化，是直接在main进行检测GPIO口高低电平，在单片机开发中应该用外部中断检测电平变化替代GPIO高低电平变化检测思路，因为存在bug单片机多少都会漏检测到的bug缺陷可能是库函数问题)
*************************************************************************/ 
void GPIO_EXIT_Interrupt(void){
    uint32 gpio_status;  //用于存中断标志位，为了清除时候用
    static uint8_t LED_Flag=0;
    gpio_status = GPIO_REG_READ(GPIO_STATUS_ADDRESS);   //读取中断状态寄存器的值  整个GPIO口的状态寄存器拿到了去查pin5
    /*
    因为是设置的pin5脚也就是中断5所以左移5到指定的bit位置
	   如: 12个引脚就有 12bit pin5就是移到5bit位置(单片机通用知识)
    */
	 if((gpio_status&(1<<5))) {    //判断是哪一个GPIO引起的中断
        os_delay_us(4000);      //软件消抖
        if(GPIO_INPUT_GET(GPIO_ID_PIN(5))==0){
            LED_Flag=!LED_Flag; //切换led灯亮灭
            if(LED_Flag==0){
                LED_ON();
            }else{
                LED_OFF();
            } //LED_Flag==0
        } //GPIO_INPUT_GET(GPIO_ID_PIN(5))==0
    } //(gpio_status&(1<<5))
    GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);  //清除中断
} //GPIO_EXIT_Interrupt
```

```c
//按键扫描成函数
//参数mode：0：不支持连续按键      1：支持连续按键
//返回1：按键被按下 返回0：按键不被按下
uint8_t ICACHE_FLASH_ATTR Key_Scan(uint8_t mode)
{
    static uint8_t key_flag=0;
    if(mode==1)     //支持连续按键
        key_flag=0;
    if((KEY_STATUS==0&&key_flag==0))
    {
        os_delay_us(5000);  //软件消抖
        if(KEY_STATUS==0 && key_flag==0)
        {
            key_flag=1;
            return KEY_ON;
        }
    }
    else if(KEY_STATUS==1)
    {
       key_flag=0;
    }
    return KEY_OFF;
}
```
  