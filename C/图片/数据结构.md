跨函数使用内存

```C
main()
{
int*p;
fun(p);   //错误：至少要传地址才能改变p的值 
int fun(int *p)
}
{
int s;
p=&s;     
}

mian()
{
    int *p;
    fun(&p);  //这里是正确的传参
}
int fun(int **q)
{
    int s;
    *q=&s;    //但是 int s  是局部变量 运行完函数就释放了  所以错误
   
}

main
{
    int*p;
    fun(&p);  //把地址 传入
}
int fun (int **q)    参数类型 是int    **q是取q地址里存储的值的地址   
{                      &p   是int*类型    取值int**q    *q就是p
    *q=(int *)malloc(4);  //这里4  是整形占4个字节   *q=p
}
```

struct Student * Create Student(void)

返回的类型          函数名         （传入的参数的类型和 变量名）

这里的*是 因为  函数运行后 返回的是地址  所以用类型 *   来作为返回类型



typedef   自定义类型

```
typedef struct Student 
{
int sid;
char name[100];
char sex;
}ST;   //ST等价于struct Student   //尽量大写

typedef struct Student 
{
int sid;
char name[100];
char sex;
}*PST;     //PST等价于struct Student*  
struct Student st;
 PST ps = &st;  //  可以看成是这样 struct Student * ps =&st 
 ps->sid=99;   //由于是指针所以不能用点句号访问  
```

 

链式队列和静态队列

静态队列必须是循环队列的目的是  当在有效的空间里  删除和 新增都是往后加  则使前面被删除的部分的内存无法使用到 所以必须使用循环队列 但是会有一个问题 在队列（尾部和头部重叠）边界处容易越界需要考虑到

 主要为了避免内存浪费

函数声明  如果用指针类型  则格式为 p+大写首字母       举例 ：   pVal



函数调用的空间多次执行则空间是同一块区域 

  且被调用的都是在栈顶分配空间 运行完先出栈释放

(n-1，a,c,b )    a  要被移到 b   借助c来    9个盘子 从a 借助c 放到b

 **双亲表示法  根据上一节点的地址来查询到下一节点的位置** （这里的顺序是随便排的 -1为父节点）
![[双亲表示法.png]]


**孩子表示法 无法推断父节点 容易查到子节点**
![[孩子表示法.png]]
这是双亲孩子表示法 可以求父节点 和子节点都很方便
![[双亲孩子表示法.png]]

二叉树表示法

左指针域指向它的第一个孩子 右指针域指向它的堂兄弟  只要满足此条件就可以把一个普通树转化为二叉树
![[一个普通的树转换为二叉树.png]]


**森林转换二叉树的 步骤 和一般转换为二叉树的差别不大   区别是 把 不同的树当作它的兄弟**

**当子节点 下只有一个节点的时候看成是孩子 用左指针其中的M就是所说的情况** 
![[森林转化二叉树.png]]


先序遍历

​	**先访问根节点	再先序访问左子树 再先序访问右子树** 

**每一个子节点都当做树 每个树都先访问它的左子树再访问它的右子树直到没有子节点才开始遍历父节点的右子树**

中序遍历

后序遍历

