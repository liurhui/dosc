```c
return(char*) &a // 取出a所在的地址，强制转换成char* 字符指针类型就是要一个字节   int* 是要取出4个字节

return *(char*) &a  // 就是取出一个字节的值
```
示例1
```C
int  check_sys()   // 这里返回的是一个int类型的值
{
	int a =1;
	return *(char*)&a;    // 注意这里的 char*
}

int main()
{
	int a =1;
	int ret =check_sys(); 
}
```
示例2
```C
int  check_sys()   // 这里返回的是一个int类型的值
{
	union
	{
		char c;
		int i;
	}u;
	return u.c;  // 达到了不用指针的效果是一样的，判断大端还是小端
}

int main()
{
	int a =1;
	int ret =check_sys(); 
}

```

#### 扫盲
	定义变量赋值，是初始化一定的空间存放数据。实际是操作内存地址，更像是封装过的。而通过指针就像是没封装过的操作内存地址。为了节省空间，更加精准，效率也会更高。可以节省机器查询的过程，尤其是在一定运行内存的单片机来说非常重要。否则会死机，内存溢出。

1、因为不同长度的地址，所以要用相同长度的类型来接收。
```plaintext
char*  //表示:char长度的地址,以此类推
short* 
int*
float*
double*
unsigned char*
....
1、以int举例：
int a =10;  //定义一个int 型变量a，也叫普通变量。
int* aa = &a;  //a用int长度存储10，用int长度的aa来接收，当a变了 aa也随之变了。即aa实际上存储的是a的地址，而不是固定值10。

2、标准叫法：int*叫指针类型， aa叫指针类型的变量（也叫指针）。

3、由于长度限制所以不能跨长度赋值 ，以int* 、double*举例：
int a =10;
int* aa=&a; //成功： aa 与 a 都是int长度，可以直接赋值。
double* bb=aa; // 报错：无法通过不同长度来直接赋值。
```
2、关于 指针与星号`*`的位置是比较自由的，以及指针数组数组指针说明。
![[指针数组示意图.png]]
```c
//由于没其他操作符，则以下三种写法是一样的，不要纠结*贴着谁。
int* a;//*贴着int写
int * a;// *不贴着int，也不贴着a写
int *a;//*贴着a写

 //因为数据可以用数组管理，指针也可以用数组管理。（常用于二维数组）
(*p)[2] //数组指针 ，p是指针  [2]是步长（步长由自己控制），+1地址后是前进几个元素。
*p[2] //指针数组，p是一个数组，[2]表示了两个指针。（步长不由自己控制）

//原因：根据优先级
() == [] > *   //同级别从左往右顺序执行
*p[2]  =>  p[2]会先结合 => 才结合*
(*p)[2] =>  (*p)先结合  => 才结合[2]


//详细说明举例

int (*p)[n]; //是数组指针（也称行指针）
这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
如要将二维数组赋给一指针，应这样赋值：
int (*p)[1]; 
int a[3][4]={ 1, 0, 2, 4, 3, 8,9,10,11,12,13,14 };
p=a; 
int *s=++p;  
int *v=++p;
printf("p=%d,v=%d",*s,*v); //int (*p)[1]; 则p=0,v=2   //int (*p)[3]; 则p=4,v=9


int *p[n]; //指针数组
执行p+1是错误的, p=a;也是错误的。因为p是个不可知的表示，只存在p[0]、...、p[n-1],且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
如要将二维数组赋给一指针数组:
	int *p[3];
	int a[3][4]={ 1, 0, 2, 4, 3, 8,9,10,11,12,13,14 };
	for(int i=0;i<3;i++){
		p[i]=a[i];
		printf("p=%d,a=%d",*p[i],*a[i]); // p=1,a=1p=3,a=3p=11,a=11
	}
这里int *p[2]  表示最多3个指针 受到a[3][4]中[4]的影响 表示步长固定为4，每++ 则跨过4个元素。
注意：虽然遍历的时候 i> 3 如5  而*p[4]会存在 但是*p[0]则失效。尽量不要这样会混乱错误。

```
动态创建多维数组
```
char (*fp*)[3];
fp = new char[2][3];
```
![[数组指针_二维示意图.png]]

3、基本用法
3.1、指针加、减操作符
![[指针地址示意图.png]]
```c
*p+=2;  //内存所存储的数据加2，不是地址+2。 

p += 1;   //后移一个地址，地址的长度根据定义的类型
p -= 1;  //向前一个

//short 是两字节 所以 是两个格子。即按类型长度为步长。
```
3.2、非指针无法用指针进行修改
```c
int addr = 0x12345678; //addr是普通变量
*addr =0; //报错：只有指针才能进行星号操作。
```
3.3、赋值
```c
char a =78;   //a是普通变量
cahr * p =&a;  // p是指针，接收了a的地址。 且搭配* 和& 拿到了a所在的地址。
*p =79; //  *p 往a的地址里赋值， 78被覆盖为79。

```
#### 指针与数组
	keil在内存块调试时，查看数组地址不需要加&，数组名称就是地址。
	指针的*p == p[0]，从js的角度来看就很明了，就像是返回用数组接收。于是可以用数组方式操作。
1、`arr ==&arr[0];`  都是表示首地址
```c
 int arr[4] = {1,2,3,4};

 //下面两句等效
 int * p = arr;    //arr是 int 型所以可以赋值地址给指变量p
 int* p = &arr[0];  
```
2、赋值
```c
int arr[4] = {1,2,3,4};
arr+3 == &arr[3];   //取下标为3的地址   等效--> *(arr + 3)  值为4

int arr[4] = {1,2,3,4};
int * p =&arr[1]; //2
//严格叫法 p[0] ：自p开始的地址为将 arr[1]设为第0号元素 
p[0] =0xAA;  //0xaa 对应是十进制是170
printf("p=%d,p[0]=%d",*p,p[0]); // 实际上 *p == p[0] == arr[1] 即2被覆盖为170

int a =10;   
int * p =&a;
p[0]=11;   //长度为1的数组  a也看做是数组的首地址
```
3、加减法
```c 
#include <stdio.h>
int main () {
	int arr[4] ={1,2,3,4};
	int*p1=&arr[0];
	int*p2=&arr[0];
	printf("%d,%d\n",((int)p2-(int)p1),arr[0]);// 0,1    强制转换为整型
	//其 p1 =p2 =&arr[0] 都是arr[0]的地址
	printf("p1=%d,p2=%d",*p1,*p2); //p1=1,p2=1


	//int*p1=&arr[0];
	//int*p2=&arr[3];
	//printf("%d \n",(p2 -p1)); // 地址相减 隐式为 4-1 =3 
	return 0;
}
```
4、遍历
```c
for(int*p =arr; p<arr+4; p++)  //arr是数组
{

}
```

#### 指针作为函数参数
	传指针可以返回多个值，直接回传省去写return。 且省拷贝的字节空间，同时效率高很多。
	普通变量 用&去传 数组名本就是地址所以没用& 。
分为输入参数、输出参数，为了修改上层函数的值（传递的都是地址）
```c
#include <stdio.h>
void sum2(int* a, int* b, int* out){
    int result =  (*a+1) +*b;
    *out =result;
}
int main () { 
   int a =10, b=11;
   int out = 0;
   sum2(&a, &b, &out);
   printf("a=%d,b=%d,out=%d",a,b,out); //a=10,b=11,out=22
    return 0;
}
```
数组传递 第一个参数地址 第二个参数长度
```c
#include <stdio.h>
int avg(int*p, int len) // int*p[] 可以简写为 int*p 都表示数组首地址
{
    int sum = 0;
    for(int i=0; i<len;i++){
		 sum+=p[i];  
    }
	return sum/len;
}

int main () {
	int arr [] = {1,2,3,4}; // arr 是 int *
    int ret ;
    ret = avg (arr,4); //范围从arr[0] 到arr[3]
	printf("ret=%d",ret); //ret=2  编程里/ 是取模
	return 0;
}
```
#### const 指针
函数的参数用const 可以认定是只作输入参数
```c

```