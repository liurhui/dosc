####  1、结构类型指针
```c++
void buy (Citizen*  owner)  //函数参数是结构类型指针owner是形参名
Citizen  shaofa  =(“shaofa”,100,NULL);  //创建初始化Citzen 结构名  shaofa是对象 的数据结构
buy (&shaofa);    //调用函数 参数为 对象地址
```

####  2、malloc
```c++
malloc() 创建   
free(p)释放  
p = NULL;  配套
```

####  3、查找整个链表里的 某个对象  语法
```c++
//链表头 找201505这个数据
Student* result = find(&ss[0], 201505);
Student * find (Student* head, int id)  
	//链表头，要查找的结构数据成员类型
{
    Student * p = head;
    while(p)
    {
        if (p ->id ==id) //符合条件       
            return p;
            p->next = p;/* code */
    }
        return NULL;  //没找到符合条件的对象
}
```

####  4、类型指针   是静态全局属性
```c++
char* str  //存储在静态存储区中，具有全局属性
char str[] = "hello world";
//中的str是存储在栈上的局部变量数组，但函数运行结束时，会清空栈的存储空间，
```
####  5、引用的 写法
```c++
test().id  ==  Object& obj = test();   
obj.id = 10;
//定义一个 引用结构类型 的对象 obj
```
####  6、virtual  虚拟继承   
	目的是调用子类编译器默认是父类   virtual写在父类成员函数类的大小，由成员变量决定与成员函数无关系多少成员函数都不影响。 但是，成员函数被声明为virtual 大小会有变化，一般占四个字节，变化的大小由编译器决定。
```c++
Parent* obj = new Child(); 
obj->Test();

class Parent
{
	public:
		virtual void Test();
};
Paretn* p = new Child();
delete p ; //配套virtual析构virtual~ Prarent

```
#### 7、this指针
	C语言 对象通过对象指针访问成员变量
```c++
class Object
{
	public: 
		int x;
		int y;
		void Test (Object* that) 
		{
			printf("x=%d, y=%din", that->x, that->y);
		}
};
int main(){
	Object obj;
	obj.x = 10;
	obj.y = 20;
	obj.Test (&obj); //点号
	
```
	这是this直接调用
```c++
#include <stdio. h>
#include <string.h>
class Object
{
	public: 
		int x;
		int y;
		void Test()
		{
			printf("x=%d, y=%d)n", this->x, this->y);
		}
};
int main()
{
	// obj的地址和this是同一个
	Object obj;
	obj.x = 10;
	obj.y = 20;
	obj.Test();
}
```



####  8、类型指针   是静态全局属性
```c++
char* str  //存储在静态存储区中，具有全局属性
char str[] = "hello world";
//中的str是存储在栈上的局部变量数组，但函数运行结束时，会清空栈的存储空间，
```
