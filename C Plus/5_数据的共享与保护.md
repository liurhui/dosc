### 作用域
	命名空间作用域包含 >  类作用域包含 > 局部作用域
	多个文件共享变量名，关键字extern，重新声明以前定义过的外部变量。
	1、main 函数之前定义的变量
		1.1、静态关键字static为内部链接性， 别的文件夹无法共享，作用域为当前整个文件。
		1.2、无static为外部链接性，其他文件用extern共享，作用域为所使用的整个文件。
	2、代码块中 定义的变量
		2.1、代码块中有static作用域为代码块，无链接性，函数结束也不会释放地址。
	3、代码块中 有关键词register
		3.1、存储为寄存器,作用域为代码块，自动使用时候分配使用后释放。
## 作用域与可见性
### 函数原型作用域
```c
// 作用域在 (这里面)
double Area(double radius);
```
### 局部作用域
    函数形参列表中形参的作用域：
	    从形参列表中的声明处开始,到整个函数体结束之处为止。
    函数体内声明的变量：
	    其作用域从声明处开始,一直到声明所在的块结束的大括号为止。
    在块中声明的标识符：
	    其作用域自声明处起,限于块中。
局部作用域示例
```c
void fun(int a){  //int a 只在大括号内
    int b(a);
    cin >> b;  // b  只在 当前行开始 至fun的}内
    if (b > 0)
    {
        int c; //c 只在 当前行开始 至if的}内
        ...
    }
}
```
### 类作用域
    类作用域于特定的成员名。
    类X的m成员具有类作用域,对m的访问方式如下:
        如果在X的成员函数中没有声明同名的局部作用域标识符,那么在该函数内可以访问成员m。
        通过点表达式`x.m`或者`X::m`访问。
        通过指针表达式`ptr->m`。
    类作用域 三种写法
        `X.m X::m ptr ->m`
 

### 命名空间作用域
```c
namespace 命名空间名{
        命名空间内的各种声明(函数声明、类声明、....)
}

/*
1、一个命名空间确定一个命名空间作用域。
2、在本命名空间声明的、不属于前述各个作用域的标识符。
3、可以直接引用当前命名空间中声明的标识符。
3.1、引用其他命名空间的标识符：
    命名空间名::表示符号
3.2、直接引用其他命名空间的标识符
    using 命名空间名::标识符名;
    using namespace 命名空间名; //或者这种写法
    
4、std命名空间:包含了C++标准程序库的所有标识符
命名空间允许嵌套
    namespace OuterNs{
        namespace InnerNs{
            class SomeClass(...);
        }
    }
4.1、使用引用SomeClass类:
    OuterNs::InnerNs::SomeClass
5、全局命名空间:
    默认的命名空间,显式声明的命名空间之外声明的标识符都在一个全局命名空间中
6、匿名命名空间:
    需要显式声明的没有名字的命名空间
    具有命名空间作用域的变量也称为**全局变量**
*/
```
作用域示例
```c++
#pragma region 作用域示例
#include <iostream>
using namespace std;
int i; // 全局命名空间中的全局变量
namespace Ns {
    int j; // Ns命名空间中的全局变
}
int main {
    i = 5; // 为全局变量赋值
    Ns::j = 6; // 为全局变量j赋值
    {
        using namespace Ns;   // 可以直接引用Ns命名空间的标识符
        int i; // 局部变量
        i = 7;
        cout << "i= " << i << endl; // 输出7
        cout << "j= " << j << endl;
    }
}
//运行结果  i=7 j=6 i=5
#pragma endregion
```
 
### 可见性
	可见性是从对标识符的引用的角度来看标识符的有效范围。
    程序运行到某一点,能够引用到的标识符, 就是该处可见的标识符。 
    可见性表示从内层作用域向外层作用域“看”能看见什么。
```pliantext
命名空间作用域> 类作用域 >局部作用域
```
	  能够引用就是可见，不能够引用就是不可见
	 1、标识符应声明在先,引用在后。 
	 2、在同一作用域中, 不能声明同名的标识符。 
	 3、在没有互相包含关系的不同作用域中声明的同名标识符, 互不影响。
	 4、如果在两个或多个具有包含关系的作用域中声明了同名标识符, 则外层标识符在内层不可见。 
	 4.1如果某个标识符在外层中声明, 且在内层中没有同一。
	 4.2标识符的声明, 则该标识符在内层可见。


### 对象的生命周期
	1、对象从产生至结束的这段时间就是它的生存期
	2、对象生命周期内，将保持他的状态（数据成员的值），变量也将保持他的值，直到被更新为止。
	 3、对象生存期分为静态和动态
#### 静态
```c
/*
    1、这种生存期与程序的运行期相同。
    2、在命名空间作用域中声明的对象具有静态生存期。
    3、在函数内部声明静态生存期对象要冠以关键字static。
    3.1、不会随着每次函数的调用而产生一个副本
    3.2、不会随着函数返回而失效(下一次调用时还保持上一回的值)
    3.3、如: static int i=5;
    3.4、未指定初值的基本类型静态变量,初值为0
*/
  
#include <iostream>
using namespace std;
int i = 5; // 命名空间作用域  //i具有静态生存期，生存周期为整个周期
int main(){
    cout << "i=" << i << endl;
    return 0;
} 
```
#### 动态
```c
/*
    1、局部作用域中声明的,没有用static修饰的对象是动态生存期的对象(习惯称局部生存期对象)。
    2、诞生于声明点,结束于声明所在的块执行完毕之时。
 */
 
#include <iostream>
using namespace std;
void fun();
int main(){
    fun(); // i=6; a=2
    fun(); // i=6; a=3
};

void fun(){
    static int a = 1;
    int i = 5;
    a++;
    i++; // i是动态生存期， a是静态生存期 区别：a第二次调用不初始化 ， i动态会被初始化。
    cout << "i=" << i << ",a= " << a << endl;
} 
```
### 类的静态成员
	1、用关键字static声明。
    2、在每个类只有一个副本,由该类的所有对象共同维护和使用。
    3、具有静态生存期,可以通过类名来访问:类名::标识符。
    4、必须在类外定义和初始化,用(::)来指明所属的类。
    5、在UML中,静态数据成员加下划线。
#### 类的静态函数成员
	1、使用static关键字声明的函数成员。
    2、属于整个类,由该类的所有对象共享。
    3、类外代码可以使用类名和作用域操作符来调用静态成员函数。
    4、静态成员函数只能引用属于该类的静态数据成员或静态成员函数。
    5、必须通过对象名才能访问非静态成员。
    6、在UML中,在静态函数成员前添加<<static>>构造型。
 静态成员函数举例
```c
class A {
	public:
	    static void f(A a);
	
	private:
	    int x;
};
void A::f(A a){
    cout << x;   // 错误 对x的引用  
    cout << a.x; // 正确 静态不允许使用非静态成员 a是形参 以对象形式调用
}

```

### 类的友元（不要随意使用友元）
	1、友元是C++提供的一种数据共享机制,可以提高程序的效率和可读性。
    2、友元破坏了数据封装和数据隐藏。
    3、使用关键字friend将其他函数或者类声明为友元。
    3.1、友元函数
    3.2、友元类
    4、通过将一个模块声明为另一个模块的友元,一个模块能够引用到另一个模块中本是被隐藏的信息。
	5、可以使用友元函数和友元类。
    6、为了确保数据的完整性,及数据封装与隐藏的原则,需要在共享和封装之间找到一个平衡。
#### 友元函数
	1、友元函数是在类声明中由关键字friend修饰说明的非成员函数,
    2、在它的函数体中能够通过对象名访问private 和 protected成员。
    3、作用:增加灵活性,使程序员可以在封装和快速性方面做合理选择。
    4、访问对象中的成员必须通过对象名。
























class的static (静态成员变量、静态成员函数)
作用  1、共享值   2、不同类对象赋值都会覆盖之前的值  
定义  在类 public中 定义 satatic变量   
初始化  在全局中初始化  
问题： 不能在构造函数中定义 否则调用不到
```CPP
class Person{
	public:
		static int m_Age; //加入static就是 静态成员变量 ，会共享数据
		//静态成员变量，在类内声明，类外进行初始化
		//静态成员变量 也是有权限的	
	
	private:  //私有权限 在类外不能访问
		static int m_other; 
		static void func2(){
			cout << "func2调用" << endl;
		}
};
//1、类外初始化实现
int  Person::m_Age = 0; 
int  Person::m_other = 10;


void test01()
{
	//1 通过对象访问属性
	Person p1;
	p1.m_Age = 10;
    Person p2;
	p2.m_Age = 20;   //最后 p1的值和p2 的m_Age的值都为 20
    //2 通过类名访问属性
	cout << "通过类名访问Age" << Person::m_Age << endl;
	//cout << "other = " << Person::m_other << endl; //私有权限在类外无法访问
```



```CPP
//静态成员函数
//不可以访问  普通成员变量
//可以访问 静态成员变量
	static void func()
	{
		m_Age = 100;
		cout << "func调用" << endl;
	};
	//普通成员函数 可以访问普通成员变量，也可以访问静态成员变量
	void myFunc()
	{
		m_A = 100;
		m_Age = 100;
	}
	
	//静态成员函数调用
	p1.func();
	p2.func();
	Person::func();
	//静态成员函数 也是有权限的
	//Person::func2();
```

