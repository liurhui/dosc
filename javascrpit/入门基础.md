### 常识
函数与对象的叫法：当函数定义在对象内部时称为对象方法。
下划线开头的变量约定熟成为私有变量
const翻译: 
		这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值。
数据结构理解为：存放数据的方式。
指数运算符：
	`cosnt num = 3**3;  ===  const num=Math.pow(3,3); `
去空格：
	`trim() trimStart() trimEnd()`
||     判断  0  null  undefined  “”  false NaN都是不成立。
??    判断   null  undefined     都是不成立， 0  “” false NaN是成立的。
&&   判断 链式 ，改 可选链  ?.  。
获取全局对象 es11 `console.log(globalThis)`   node `console.log(global)`。
for....in  遍历 对象的key  `for (const item in obj) {}` 。
node v14  不支持es12语法 。
逻辑空赋值运算 `let message = 0; message ??= "default value"` 。
 存在 则再调用`obj.foo && obj.foo()`

**babel**
`/*#__PURE__#*/ ` 纯函数  标记意思无副作用  webpak 压缩 tree-shaking
虽然转换了但是没有用到，bulid时删除掉。


**class常见的方法**
判断类型：`console.log(typeof Person); //本质还是 function `
查看 Person 的非静态外所有方法的配置信息（可读、可删...）:
`console.log(Object.getOwnPropertyDescriptors(Person.prototype))`


**奇奇怪怪的知识**
	VO GO  官方是在es3 文档内
```js

function foo(m,n=m+1){
	console.log(m,n)
}
foo();  // undefined,NaN
```


#### 可选链操作符
```js
早期
let dataList = res && res.data && res.data.list
现在
let dataList = res?.data?.list

```
##### 使用
babel7以上的版本，可以添加以下2个`devDependencies`依赖
后在.babelrc或者babel.config.js中这加入2个插件(plugins属性放在JSON顶层)
```
{ "plugins": [ 
	"@babel/plugin-proposal-nullish-coalescing-operator", 
	"@babel/plugin-proposal-optional-chaining" 
	] 
}
```
##### 与??区别
```js

let value = value1 && value2
// null 或 undefined 才value2
//`0`,`false`,`""` 还是 vlaue1

let dataList = res?.data?.list
// 避免未知 但可能存在的属性。

```


#### 高阶函数
	把函数当参数，或，函数当返回值，就叫高阶函数。
**传入函数**
```js
function calc(num1, num2, calcFn) {
  console.log(calcFn(num1, num2))
}
  
function add(num1, num2) {
  return num1 + num2
}

var m = 20
var n = 30
calc(m, n, add)

```
**返回函数**
```js
function makeAdder(count) {
  function add(num) {
    return count + num
  }
  return add
}

var add5 = makeAdder(5)
console.log(add5(6))
```


### 数组高阶函数常用到的
	参数：  每个下标对应的值，每个下标，整个数组即nums
	实际上每次都会把每个都传进来，我们不用的就不写 
#### filter过滤
分组
```js
//返回： return 必须是布尔值
//实际上就是遍历整个nums ， true的就push进接收的数组  false就不返回。
//至于是true还是false由我们的逻辑编写。 
var newNums= nums.filter((item, index, arr)=> boolean)
```
#### map映射
修改
```js
 var nums=[10, 5, 11, 100, 55];
 
 var newNums2 = nums.map(function(item) {
	  return item * 10
 })
 console.log(newNums2) //[100, 50, 110, 1000, 550]
```
#### forEach迭代 没返回值
取出来    
	每次遍历一个项
	break是在for去用，forEach 错误是抛异常
```js
 nums.forEach(function(item) {
   console.log(item)
 })
```
#### find/findIndex 返回符合的项
查询
```js
var friends = [
  {name: "why", age: 18},
  {name: "kobe", age: 40},
  {name: "james", age: 35},
  {name: "curry", age: 30},
]

var findFriend = friends.find(function(item) {
   return item.name === 'james'
 })
 console.log(findFriend)  //{name: 'james', age: 35}

  

var friendIndex = friends.findIndex(function(item) {
  return item.name === 'james'
})
 console.log(friendIndex) //2
```
#### reduce 累加
相当于 迭代+累计
(上一次的返回值，下次的值)，默认初始值
```js

//reduce 相当于这种流程封装
var nums =[ 10, 5, 11, 100, 55];
var total = 0;
for (var i = 0; i < nums.length; i++) {
  total += nums[i]
}
console.log(total)



var total = nums.reduce(function(prevValue, item) {
  return prevValue + item
}, 0)
console.log(total)
//prevValue: 0, item: 10
//prevValue: 10, item: 5
//prevValue: 15, item: 11
```


### 闭包（Closure）
堆是存放，栈是执行。
**每门编程都有闭包广义理解上来说分：** 词法闭包（编译时定义）、函数闭包。
**闭包目的：** 自由变量，即使脱离捕捉时，也能照常运行。
**两部分组成：** return函数+可以访问外层（上层、上上层、全局）的自由变量。
闭包实际上是一个结构体。所谓的词法就是在编译期间就已经被绑定。
**在判断是否闭包有个细节**
	可以访问（可以但没有用到外层变量）和必须访问（必须用到了外层变量），一般以严谨后者为判断基准。

##### 内存泄漏理解
	其实不管是栈还是堆都可以看作每个都是分有指针和执行体两部分。
	全局执行上下文、函数执行上下文 其实都会先找自己开辟的GO/AO当自己的没找到直接找上层的，直到没有就undefined ,也就是叫作用域链。

	1、函数对象是分成 上层作用域（就是保存GO的地址）、函数执行体两部分。
	函数执行时候，创建函数上下文（栈上），同时栈需要一块AO存放于是生成AO(堆存函数的变量)且指向这个AO。
	当函数执行完毕销毁函数上下文同时销毁了AO 
	
	闭包
		GO存着A函数的地址，且生成了A函数对象。
		当A函数执行时候，创建了函数上下文，且生成了AO ,
			函数上下文的指针指向AO
		AO内又有函数B于是又创建了B函数对象，且指向的是AO,
		当执行完毕后，return出去了B函数地址， 赋值给了某个GO的变量，这个变量指向了B函数地址。
		随之A函数释放了。AO因为被B函数对象的商城作用域所指向，所以没被释放。
		当B函数执行时候，创建了函数上下文，且生成了AO,
			函数上下文的指针指向AO，（但是自己没有于是找上层AO就找到了B函数对象所指向的AO）。
	解决泄漏
		当B函数也执行完毕后，实际上GO 还指向函数对象 函数对象的上层作用域还指向GO/AO的地址，形成了循环指向，只要 把GO的变量指向函数对象的地址改为 null ，根据从根开始指向没有构成循环指向就会被释放。
```js

```

### this指向
	面试细节坑点： 注意window 有name属性 为"" , 注意不是undefined。
	编译环境不同this区别：
		node xx.js   console.log(this) 是 空对象 {}
		浏览器  console.log(this)是   window
	原因： 
		 node 源码写在modules的cjs的loader.js ，
		 会放到一个函数内通过 xxxx.apply({}) 参数是空对象。
	本质：实际上this还是 指向上下文 的调用栈 AO对象的问题。
	 隐式声明： 实际编译时候 会补上 call 只是this是调用者。
#### bind 、call、apply  使用场景
	相同点：都是 函数需要使用到别人的变量，重置this。
	区别：
		1、bind简化了每次都改变指向，像call、apply就需要用的时候每次都改变指向
		2、bind是开辟新空间 !== 原本函数。 call是等于原本函数。
		3、apply/call/bind: 当传入null/undefined时, 自动将this绑定成全局对象
	使用场景中主要分：对象定义和函数定义，   
		函数又分： 普通函数和箭头函数（找上层）。
		4、bind 可以把this拿到直接存到一个变量， 调用这个变量节省了每次用call apply去重新指向this。   bind相当于 有call 和apply的效果 还具备
#### 绑定规则
	常规分为4种，与写的位置无关，与调用有关。
	当this是window时，属性不存在则 undefined
	细节：
	一个全局obj 内的普通函数，函数的this 是外层即obj，非winwdos。
	一个全局obj 内的箭头函数，函数的this 分两种情况：
		外层是普通函数嵌套着，this是普通函数的this即 obj,
		外层没有普通函数嵌套，this是全局 winwdos。
##### 1、默认
	就是不通过 .调用函数
```js
// 声明
function foo() {
  function bar() {
    console.log(this)
  }
  return bar
}
//常规调用
var fn = foo()
fn() //this: window


//2、隐式
var obj = {
  name: "why",
  eating: fn
}
obj.eating() // 隐式绑定   {name: "why",eating: ƒ}
``` 
##### 2、隐式   
	常见于对象内有个属性指向某个函数 
```js
// 这里的 obj.name  无论怎么调用都会指向 why  
//   this.name 会根据调用者从而改变this的指向。
var obj = {
  name: "why",
  eating: function() {
    console.log(this.name + "在吃东西")
  },
  running: function() {
    console.log(obj.name + "在跑步")
  }
}

  
//隐式 直接会被转换到obj内部 
obj.eating() //why在吃东西
obj.running()  //why在跑步   
 
var fn = obj.eating  // 声明的fn是全局的，this是 window 
fn() //在吃东西    正常是undefined在吃东西  因为 window 有name属性值是"" 
```
##### 3、显示  
	具有强制的行为，常见于call、apply、bind 来改变毫无关联的this指向 
	call 参数逗号分隔
	apply 参数数组
	bind  会拿到 this的本身
```js
function foo(num1,num2) {
  console.log("函数被调用了", this,num1,num2)
} 
 
var obj = {
  name: "obj",
  //eating:foo
}
// obj.eating(20,30)  //函数被调用了 {name: 'obj', eating: ƒ} 20 30

foo.call(obj,20,30)   //函数被调用了 {name: 'obj'} 20 30
foo.apply(obj,[20,30])  //函数被调用了 {name: 'obj'} 20 30



var newFoo = foo.bind("aaa",20,30);
console.log(newFoo(10,5)); //函数被调用了 String {'aaa'} 20 30
```
 
##### 4、new   构造器  有很多层次嵌套的用法
```js


```

##### 5、扩展
	间接调用
```js
var obj = {
  name: "why",
  eating: function() {
    console.log(this.name + "在吃东西")
  }
} 

 (obj.eating)();  //相当  obj.eating();   obj{}
 (b= obj.eating)();  
	 // 相当 var b=obj.eating;    b();    window
```

##### 5.1、arguments转成数组
	通过call 把this 指向 arguments
	原因： arguments 借 array的slice方法把全部是都截取出来。
	环境区别：浏览器全局下是没有arguments， node全局下是有arguments（原因还是当模块，放函数。）
```js
function foo(num1, num2) { 
	//1
  var newArr2 = Array.prototype.slice.call(arguments)
  console.log(newArr2)
	//2
  var newArr3 = [].slice.call(arguments)
  console.log(newArr3)

  
  // 2.3.ES6的语法
  var newArr4 = Array.from(arguments)
  console.log(newArr4)
  var newArr5 = [...arguments]
  console.log(newArr5)
}
//测试调用
foo(10, 20, 30, 40, 50)

```

##### 5.2、call举例 
	写谁就是转谁  全局调用下  this 就算 window
```js
function sum(num1, num2) {
  console.log("sum被调用", this.fn(), num1, num2)  // sum被调用 undefined 20 10
  return num1 + num2     
}

function bar() {
    console.log("bar函数被执行", this)  // {as:1, fn: ƒ}
}

  
var a ={
    as: 1,
    fn: bar
}

// 系统调用
var result = sum.apply(a, [20,10])  //  相当于  sum 可以去操作a的内部
console.log(result)   //30



```




#### 优先级
 new绑定 > 显示绑定(apply/call/bind) > 隐式绑定(obj.foo()) > 默认绑定(独立函数调用)
```js
// 3.更明显的比较
function foo() {
  console.log(this)
}

var obj = {
  name: "obj",
  foo: foo.bind("aaa")
}
obj.foo()  //   aaa   
```
new的优先级高于隐式绑定
```js
//1、
function foo() {
  console.log(this)
}

var bar = foo.bind("aaa")
bar(); //aaa
var obj = new bar()   //foo {}


//2、
//如果  是obj{} 则是隐式      ，是foo{} 说明是new  
var obj = {
  name: "obj",
  foo: function() {
    console.log(this)
  }
} 
var f = new obj.foo()  // foo{}
```




### 箭头函数
	补充： 不能用 new 实例化 箭头函数。
	箭头函数没有arguments，会去上层去找 ，但是到全局后则报错。浏览器全局没有arguments
**简写示例**
```js
//1、一个参数一个执行语句 
nums.forEach( (item)=> {console.log(item)} )

简写为
nums.forEach(item => console.log(item) )



//2、无参数 只有一个执行语句
var bar = () => {
   return { name: "why", age: 18 }
}

简写为
var bar = () => ({ name: "why", age: 18 })

```
**常见的  定时器setTimeout函数**
```js
var obj = {
  data: [],
  getData: function() { 
      var _this = this
     //写法1 普通函数传this
	setTimeout(function() {
	   var result = ["abc", "cba", "nba"]
	   _this.data = result
	}, 2000); 
	//写法2 箭头函数
	setTimeout(() => {
	  var result = ["abc", "cba", "nba"]
	  this.data = result
	}, 2000);
  }
}

//测试调用
obj.getData()
```


### 纯函数写法  react 比较吃这个概念
**柯里化 和组合函数 完全是在写法上的讲究，看源码这种写法必须要熟悉为前提。**
react 的状态管理redux（锐大可斯）比vuex复杂。用到reducer就需要纯函数来写。
	1、不操作IO不操作触发事件，不修改全局变量或外部参数。(也就是不改变源对象或数组)
	2、确定输入，也确定输出。
	

##### 柯里化  转换的过程称为柯里化
**1、基本演变写法**
	参数:  一次传入多个（或一个） 多次传入参数 。
```js
function add(x, y, z) {
  return x + y + z
}


// 用柯里化实现add
function sum1(x) {
  return function(y) {
    return function(z) {
      return x + y + z
    }
  }
}
var result1 = sum1(10)(20)(30)



//可以用箭头函数简化 function嵌套麻烦的写法
var sum2 = x => y => z => {
  return x + y + z
}


// 去掉return 极简写法
var sum3 = x => y => z => x + y + z
console.log(sum3(10)(20)(30))
```
**2、示例  传入函数 返回新函数**
```js
function add1(x, y, z) {
  return x + y + z
}

// 柯里化函数的实现hyCurrying
function hyCurrying(fn) {
  function curried(...args) {  // 不管怎么传参数都会被push进数组
	  //todo
  } 
  return curried
}

var curryAdd = hyCurrying(add1)

console.log(curryAdd(10, 20, 30))  //一次全传完
console.log(curryAdd(10, 20)(30))  //分两次传 一次两个  一次一个
console.log(curryAdd(10)(20)(30))  //每次传一个 传三次
```
**2.1、实现todo    集齐参数逻辑，拼接**
```js
 
function hyCurrying(fn) {
  function curried(...args) {
    // 判断当前已经接收的参数的个数, 可以参数本身需要接受的参数是否已经一致了
    // 1.当已经传入的参数 大于等于 需要的参数时, 就执行函数
    if (args.length >= fn.length) {

      // fn(...args)

  // 这里用 apply 目的是接收外部curryAdd() 传递this 时 要把当前的指向改为传递的this
      // fn.call(this, ...args) //  call 用... 解构
      return fn.apply(this, args)

    } else {
      // 没有达到个数时, 需要返回一个新的函数, 继续来接收的参数

      function curried2(...args2) {
        // 接收到参数后, 需要递归调用curried来检查函数的个数是否达到
        return curried.apply(this, args.concat(args2))
    }
      return curried2
    }
  }

  return curried
}
```
##### 组合函数
	简易写法 主要看结构
```js
function double(num) {
  return num * 2
}
 
function square(num) {
  return num ** 2
} 

// 实现最简单的组合函数
function composeFn(m, n) {
  return function(count) {
    return n(m(count))
  }
}

var newFn = composeFn(double, square)
console.log(newFn(10))
```



### 对象
	对象的属性是具有权限的配置项（也叫描述符），通过defineProperty来设置描述符。
	函数声明后，按调用方式分为：普通函数、构造函数。
	函数也是一个对象，所以可以用对象的方法获取构造函数的原型。
#### 对象方法备忘（可以忽略）
**争对原型：**

	获取obj对象原型 Object.getPrototypeOf(obj) 
	设置newobj原型为obj Object.setPrototypeOf(newobj,obj) 
	也可以给对象加属性 Object.defineProperty() 
**争对键值对：（entries es8补充的）**

	返回值数组    为了方便后续遍历操作
	获取 键 Object.keys(obj)  
	获取 对 Object.values(obj)
	设置值Object.values(["abc", "cba", "nba"])   
			//[ 'abc', 'cba', 'nba' ]
	设置值 Object.values("abc") 
			//[ 'a', 'b', 'c' ]
	获取键值对 Object.entries(obj) 
			//[ [ 'name', 'why' ], [ 'age', 18 ] ]
	设置键值对Object.entries(["abc", "cba", "nba"]) 
	//[ [ '0', 'abc' ], [ '1', 'cba' ], [ '2', 'nba' ] ]
**逆转回对象**

	多维数组键值对转换为对象 Object.fromEntries()
```js
// 2.Object.fromEntries的应用场景  路由解析
const queryString = 'name=why&age=18&height=1.88'
const queryParams = new URLSearchParams(queryString)
for (const param of queryParams) {
  console.log(param)
}

const paramObj = Object.fromEntries(queryParams)
console.log(paramObj)//{ name: 'why', age: '18', height: '1.88' }
```
	
#### 1、对象有两种创建方式
```js
//第一种   这种代码多了不好维护
var obj = new Object()
obj.name = "why"
obj.age = 18
obj.height = 1.88
obj.running = function() {
  console.log(this.name + "在跑步~")
}



//第二种   于是有了这种写法   常规是这样写
var info = {
  name: "kobe",
  age: 40,
  height: 1.98,
  eating: function() {
    console.log(this.name + "在吃东西~")
  }
}

// 扩展写法 工厂模式 
function createPerson(name, age, height, address) {
  var p = {}
  p.name = name
  p.age = age
  p.height = height;
  p.address = address

  p.eating = function() {
    console.log(this.name + "在吃东西~")
  }

  p.running = function() {
    console.log(this.name + "在跑步~")
  }
	 return p
}

var p1 = createPerson("张三", 18, 1.88, "广州市")
var p2 = createPerson("李四", 20, 1.98, "上海市")
var p3 = createPerson("王五", 30, 1.78, "北京市")
// 工厂模式的缺点(获取不到对象最真实的类型)
console.log(p1, p2, p3)

```

#### 2、函数的有两种调用方式 
	一个函数声明后，用new 则变成构造函数，否则就是普通函数。
	区别：
			普通函数无法获取到函数的命名（字面量）。 
	 意义：
			构造函数空间是独立的，但是原型是共同的，所以可以抽离公共代码放在原型上。
**构造函数和普通函数**
```js
function foo() {  // 声明
	console.log("foo 函数体代码")
}

foo() //这种调用叫：普通函数

var f1 = new foo()  //这种调用叫：构造函数
console.log(f1)  //  foo {}
```
#### 3、Object.defineProperty 针对对象颗粒度控制 
	也就是 可读、可删、可遍历、变量值。
	Object.getOwnPropertyDescriptor(obj, "name")  获取单个属性描述符
	Object.getOwnPropertyDescriptors(obj)  获取所有属性描述符
	Object.seal(obj)   不可删除 configurable: false
	Object.preventExtensions(obj)  禁止对象继续添加新的属性
	Object.freeze(obj)  不可修改 writable: false
	Object.keys(obj)   遍历
	... 
属性描述符 示例   
```js
var obj = {
  // 私有属性(js里面是没有严格意义的私有属性)
  _age: 18,
  _eating: function() {},
  set age(value) {
    this._age = value
  },
  get age() {
    return this._age
  }
}

Object.defineProperties(obj, {
  name: {
	 // 以下默认值false
    configurable: true,// 删除
    enumerable: true,// 枚举 （下标遍历）
    writable: true,  // 写操作 
    
    value: "why" // 默认值undefined
  },

  age: {
    configurable: true,
    enumerable: true,
    get: function() {
      return this._age
    },
    set: function(value) {
      this._age = value
    }
  }

}) 
// 1.禁止对象继续添加新的属性
	var obj = {
	  name: 'why',
	  age: 18
	}
	Object.preventExtensions(obj)
	obj.height = 1.88
	obj.address = "广州市"
	console.log(obj)

//2、禁止删除
	Object.seal(obj)
	delete obj.name
	console.log(obj.name)

// 3.让属性不可以修改(writable: false)
	Object.freeze(obj)
	obj.name = "kobe"
	console.log(obj.name)

// 4.测试enumerable的作用
	for (var key in obj) {
	  console.log(key)
	}
	console.log(Object.keys(obj))
```

### 原型 （前提：对象了解） 
	原型是字面意思，实际是个对象{} 所以叫原型对象
 	1、prototype 叫显示原型， __proto__ 叫隐式原型。
	2、__proto__ 指向prototype，两种为一对，统称为原型。 
	3、console.log()是无法打印出 __proto__ 上的属性的。所以叫隐式原型。
	4、目的：看这个定义的是啥类型的 Object、Function、Array、String等。
	5、作用：对象自身没查到属性或方法 -> 会自动往原型prototype 找。
	
	6、查看原型 有两种（等效）： 
			浏览器提供了 __proto__ 属性来找prototype  
			es5提供了 Object.getPrototypeOf()  
			
	7、设置原型(把obj 作为 newobj对象的原型)：  
			1和2 一般用于继承的时候用到比较多
			 Object.setPrototypeOf(newobj,obj)  得自己封装
			 Object.create(obj)   最新的封装 
			 Object.defineProperty()  也可以达到效果
			 obj.__proto__   
	8、判断原型是否为自己
			obj.hasOwnProperty();  在原型false 在自己true
			console.log("address" in obj)  只要存在原型或 自己 true, 都不存在false
	9、遍历原型和自己的属性
			for (var key in info) { console.log(key) } 只要存在原型或自己 都被遍历
	10、判断某个原型是否在 原型链上  尤其是继承
			stu instanceof Student  存在true不存在false 只能function
			obj.isPrototypeOf(info)  存在true 不存在false 可以obj 和function
			
```js
var obj = {
  name: "why",
  age: 18
}
 
var info = Object.create(obj, {
  address: {
    value: "北京市",
    enumerable: true
  }
})
// 两个参数    info 继承 obj    address 是info 私有

```
#### 对象-函数-原型结构 理解后就知道原型链的指向流程
	函数有两个prototype 且不同，一个是显示原型，一个是__proto__ 指向的也叫prototype
	每一个函数相当于后面 有 function Function() 和 function Object() 两个存在
	就是因为这样所以有了原型链 一个指向一个的原型对象
```js
var obj = {
	 name: "why"
}
对象声明只有  __proto__ -> prototype原型对象 



function Foo() { }  
函数声明后 出现6个基础空间，分自己和Fuction类和Object类 。
原因：1、 function 顶层链是Function类 
2、new 后是个对象 出现 __proto__  

Fuction的 prototype(原型对象) 是个对象有属性 { __proto__ ,constructor }
Object的 prototype(原型对象) {constructor,valueOf(),toString()}  
	//是没有__proto__ 属性为null  
Foo的 prototype(原型对象) 是个对象有属性 { __proto__ ,constructor }


从理解上来说
空间：   (<> 表示相互指向， > 表示单向指向。)
	声明后 Foo.prototype （叫显示原型）  <-> Foo原型对象  
	声明后 Foo.__proto__ -> Fuction原型对象 
		  
	声明后 Fuction.prototype（叫显示原型）<->Fuction原型对象   
	声明后 Function.__proto__ -> Fuction原型对象  
		//因为Function 自己是个构造函数 所以 Function也有一个__proto__
		 
	声明后 Object.prototype（叫显示原型）<-> Object原型对象    
	声明后 Object.__proto__ -> Fuction原型对象  
		//Object 又是个类也叫构造函数 所以 Object也有一个__proto__
	
	函数又是对象  可以说原型对象 都是 Object.prototype 管理，所以
		Object.prototype（叫显示原型） ->Fuction原型对象   
		Object.prototype（叫显示原型） ->Foo原型对象  
	得出：Object.prototype.valueOf() 来看 原型是谁
	
		  
	而 Function 和Foo 的原型对象的 原型 即__proto__ 是指向 Object的原型对象
		原型对象Function.__proto__ -> Object原型对象  
		原型对象Foo.__proto__ -> Object原型对象  
	 
	当 var foo1 = new Foo() 后  
		foo1对象 也有__proto__ ->Foo原型对象 

一组	
 Foo.prototype  和Foo.__proto__ 在一个空间   声明时自动创建出来
 {constructor：Foo 、__proto__} 一个空间   原型对象  声明时自动创建出来
二组
 Fuction.prototype 和Fuction.__proto__ 一个空间  声明时自动创建出来
 {constructor：Function 、__proto__}  一个空间  原型对象  声明时自动创建出来
三组
  Object.prototype 和Object.__proto__ 一个空间   声明时自动创建出来
 {constructor：Object 、__proto__}  一个空间 原型对象  声明时自动创建出来

第7个空间  new 后出现
	foo1.__proto__    一个空间


简述上面关系就是：
	每个空间 都有 __proto__  
	这么多空间 是因为 一个构造函数 即是 函数类又是对象类， 而对象类又是一个构造函数，函数类又是个对象。把每个__proto__连起来就是原型链。
	自己的 原型对象的constructor 指向自己（没继承转向前），  __proto__ 是找上层也叫原型链，
	
代码 找原型写法

console.log(Foo.prototype === Foo.__proto__) //false 
//因为 Foo.__proto__ -> Fucntion.prototype
//Foo.prototype.constructor  ->Foo

console.log(Foo.prototype.constructor)
console.log(Foo.prototype.__proto__)
console.log(Foo.__proto__.constructor)

console.log(Foo.__proto__.__proto__.constructor) //Foo ->Function ->Object
console.log(Foo.__proto__.__proto__) //[Object: null prototype]{}
```
 ![[构造函数的原型关系图.png]]

#### 对象看 原型的方法
	对象操作属性时，会触发get set内置函数，get是原型链工作流。
```js
var obj = { name: "why" }
obj.__proto__.age = 18   

console.log(obj) // obj = { name: "why" }
console.log(Object.getPrototypeOf(obj)); //age
console.log(obj.__proto__); //age

```
#### 对象设置 原型的方法 
	目的：复用，将newoobj对象的原型指向obj对象时写法。
```js
var obj = {
  name: "why",
  age: 18
}
 
obj.__proto__ = {
  address: "北京市"
}
等效
Object.defineProperty(obj, "address", {
  value: "北京市"
}) 
```
#### 构造函数看 原型的方法
```js
function Person() {  //1、生成prototype 空间
  this.name = "why"
  this.friends = []
}

Person.prototype.eating = function() {
  console.log(this.name + " eating~")
}
 
var p = new Person()  //p可以访问Person 的 name friends  eating() 

console.log(Object.getPrototypeOf(p)); //eating()
console.log(p.__proto__) // eating()
console.log(p)//Person { name: 'why', friends: [] }

```
#### 构造函数  内存空间分配机制
	一、对象的执行上下文空间结构
		1、parentScope 
		2、prototype（开辟且指向一个原型对象空间a)
		3、函数执行体(new后指向p1对象空间)
	二、new对象后执行上下文结构
		1、p1开辟且(指向一个 p1对象空间 __proto__(且  __proto__ 指向a) )
```js
function foo() { }	 //prototype  存 ox100 -> 地址0x100  constructor 

foo.prototype 是个{} 有个属性  constructor ，constructor 就是 foo 

可以通过 Object.defineProperty 修改constructor 的指向
	Object.defineProperty(foo.prototype, "constructor", {
	   enumerable: true,
	   configurable: true,
	   writable: true,
	   value: "哈哈哈哈"
	}) 
 

var p1 =new foo()  // __proto__   存 0x100  ->constructor  
var p2 =new foo()   //__proto__   存 0x100  ->constructor  

先找 自己的私有，没有才通过 __proto__  找 prototype。 __proto__是个属性包含在私有
console.log(p1)// 就是Person ，而Person。prototype 的 则需要用 p1.__proto拿。
//由于__proto__的部分是无法打印出来的。所以Person.prototype是无法直接看到

console.log(p1.__proto__ === Person.prototype)   //true
console.log(p2.__proto__ === Person.prototype)   //true
console.log(p1.__proto__ === p2.__proto__)   //true


p1.name = "why" //当 p1存在 name属性 就不会找原型

//以下三种 写法操作的都是同一个空间 Person.prototype
Person.prototype.name = "james"  
p2.__proto__.name = "curry"
p1.__proto__.name = "kobe"

console.log(p1.name)
```
 
 
#### 原型链
	原型链就是多个  obj.__proto__.__proto__.__proto__  
原型链复用 简化代码 出现了 继承
 
#### 继承
	目的：子类实例化，去继承父类的方法和变量。为了就是抽离出逻辑。
	理解： 应当从构造函数，多次实例化子类的角度看待弊端。
	说明： 下面的 原型链继承、借用构造函数继承、原型式继承 只是一种写法便于学习的命名，实际上是一种推演的过程，综合得出优缺点，把借用构造函数继承和原型式继承结合，才有工厂模式来写解决了优缺点。实际上继承一般用这种组合形式去实现 属性、方法的继承写法。
##### 原型链继承 
	 继承写法： var p = new Person();  Student.prototype = p;
	这种形式有3种弊端
	1、__proto__ 是隐式原型无法被console.log()，不利于调试。
	2、prototype共享，子类 通过 .push 等方法具有get操作会以原型链方式查询 ，当自己没有，而原型存在时会操作原型从而共享会造成串扰的效果。
	3、子类有自己参数 和父类参数时，不好封装参数传递。
```js
// 父类: 公共属性和方法
function Person() {  //1、prototype
  this.name = "why"
  this.friends = []
}

Person.prototype.eating = function() {
  console.log(this.name + " eating~")
}

  
// 子类: 特有属性和方法
function Student() {  //1、prototype
  this.sno = 111
}

//2、new后 就有__proto__， __proto__是指向prototype
//Student的prototype 改为 p ，即 Student原型是 p，只要new Student的 __proto__ 就是p

var p = new Person()  //p可以访问Person 的 name friends  eating() 
Student.prototype = p  // Student 指向 p ，则Student 销毁自己的原型。


console.log(p.__proto__) // eating
console.log(p)//Person { name: 'why', friends: [] }


 //这时候的studying 相当于挂到了 p上面
Student.prototype.studying = function() {
  console.log(this.name + " studying~")
}

//3、new后 就有__proto__ 所以  stu.__proto__ === p
var stu = new Student()     


// 原型链实现继承的弊端示例:
// 1.第一个弊端原因:  隐式原型
 console.log(stu.name)

// 2.第二个弊端: prototype 是被共享的会串扰
var stu1 = new Student()  
var stu2 = new Student()

注意两点：直接赋值是在自己私人作用域， 通过方法 如.push 具有 get操作会找原型，所以是引用，是在prototype上操作会共享。
// 私人作用域不共享
stu1.name = "kobe"  // 属于stu1自己 作用域
console.log(stu2.name) // undefined

sut1.friends =[] // 这种是给自己加，私人作用域不共享     
stu1.friends.push("kobe")  // 获取引用, 修改引用中的值, 会相互影响 
console.log(stu1.friends)  //kobe
console.log(stu2.friends)  //kobe

  
// 3.第三个弊端: 在前面实现类的过程中都没有传递参数
//传递参数有父类 又有自己的私有时，不好传递。
var stu3 = new Student("lilei", 112)

```
##### 借用构造函数继承
	继承写法(分开两步先属性后方法)： 
		1、属性：Person.call(this, name, age, friends); 
		2、方法: var p = new Person();  Student.prototype = p;
	目的：
		解决原型链继承的不可传参数。
	弊端： 
		调用两次 是 一次 new Person()   一次是call时候
		当子类 new的时候即使不传参数 也会拿到父类的属性（只是值是undefined）。
理解
	1、 student 通过 call  指向person 拿到 变量
	2、改变sutudent的 prototype 指向 person 的 protp  实现继承 person 的方法
```js
// 父类
function Person(name, age, friends) {//1、prototype
  this.name = name
  this.age = age
  this.friends = friends
}
//父类方法 写在 原型上
Person.prototype.eating = function() {
  console.log(this.name + " eating~")
}

  
// 子类
function Student(name, age, friends, sno) { 
  Person.call(this, name, age, friends) // this 指向了Person
  // 目的是不在子类进行逻辑操作，所以不能直接赋值写法，转向去父类
  // this.name = name
  // this.age = age
  // this.friends = friends
  this.sno = 111
}

var p = new Person()    
Student.prototype = p   //  Student 销毁 原型对象 指向p

Student.prototype.studying = function() {  
  console.log(this.name + " studying~")
}

   
var stu = new Student("why", 18, ["kobe"], 111)//Person {name  age friwnds}
 
// 原型链实现继承已经解决的弊端
// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的 
// 2.第二个弊端: 创建出来两个stu的对象
var stu1 = new Student("why", 18, ["lilei"], 111) //是加到自己stu1  __proto__ 上面去的
var stu2 = new Student("kobe", 30, ["james"], 112)
stu1.friends.push("lucy")
console.log(stu1.friends)//stu1  __proto__  {sno   ,name ,age ,friends}
console.log(stu2.friends) //stu2  __proto__  {sno   ,name ,age ,friends}
//  3.第三个弊端: 在前面实现类的过程中都没有传递参数

 
// 强调: 借用构造函数也是有弊端:
// 1.第一个弊端: Person函数至少被调用了两次
// 2.第二个弊端: stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要
```
##### 原型式继承
	目的：解决借用构造函数 属性的传递时调用两次父类问题
			 Object.setPrototypeOf(newobj,obj)  得自己封装
			 Object.create(obj)   最新的封装
```js
1、这种是es5才提供的api  Object.setPrototypeOf()
function createObject1(o) {
  var newObj = {}
  Object.setPrototypeOf(newObj, o)   //newObj.__proto__ ->o
  return newObj
}
 var info = createObject1(obj)
 console.log(info) // {}
 console.log(info.__proto__)  //obj{ name: "why", age: 18}


2、早期是这么写的  实际场景不要去直接操控 newObj.__proto__ = o
function createObject2(o) {
  function Fn() {}
  Fn.prototype = o
  var newObj = new Fn()  // 相当于  newObj.__proto__ = o  
  return newObj
}

3、现在也提供了封装好的 Object.create() 方法 等效上面的写法
var info = Object.create(obj)
```
##### 组合式继承
```js

```

### 迭代器  当接口看
	Array、Set、Map  、 函数的arguments  都内置迭代器
	迭代器是没有index的，这里只是我们好理解
	判断是否为可迭代 xxx[Symbol.iterator]
	for...of （遍历 专用在迭代器写法的对象） 
	可以用生成器简化迭代器的写法（生成器是特殊的迭代器）
#### 忘记了看这个理解
**什么是迭代器：**
	目的对象 上遍访的对象，无需关心对象内部。
	英文 iterator protocol （迭代器协议）
next 方法要求
	**next是无参数函数，返回 两个属性对象：done、value。**
	1、done 是布尔值， 完成true,  未完成可继续false。（有value时，done可以省略不写）
	2、value  返回值。 
**模板**
```js
const obj ={
	next:function(){
		return { done: true, value:nba }
	}
}
```
**简易示例**
```js
const names = ["abc", "cba", "nba"]
let index = 0

const namesIterator = {
  next: function() {
    if (index < names.length) {
      return { done: false, value: names[index++] }
    } else {
      return { done: true, value: undefined }
    }
  }
}
//多次调用 结束了都是true
console.log(namesIterator.next()) // { done: false, value: "abc" }
console.log(namesIterator.next()) // { done: false, value: "cba" }
console.log(namesIterator.next()) // { done: false, value: "nba" }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined } 
```

#### 官方内置迭代 方法
```js
//数组
const names = ["abc", "cba", "nba"]
console.log(names[Symbol.iterator])   
for (const item of names) {
  console.log(item)
}
// Map/Set
const set = new Set()
set.add(10)
set.add(100)
set.add(1000)

//函数arguments
function foo(x, y, z) {
  console.log(arguments[Symbol.iterator])
  for (const arg of arguments) {
    console.log(arg)
  }
}
foo(10, 20, 30)
```
#### 判断题
1、常见数组写法 因为迭代器原理 `const newNames = [...names, ...iterableObj]`
2、es9新增的不是迭代器原理 是键值对  `const newObj = { ...obj }`
3、数组解构是迭代器原理    `const [ name1, name2 ] = names`
4、对象解构 不是迭代器原理  `const { name, age } = obj`
5、 参数必须是可迭代对象，否则报错   `new Set(iterableObj)`
6、参数必须是可迭代对象   `const arr1 = Array.from(iterableObj)、`
#### 自定义迭代 对象
由模板可以看出变量是独立的 使得 全局作用域常与了工作。 我们得封装到内部。
1、Symbol    （根据可迭代协议要求，必须实现 @@ iterator）
2、遍历 改为内部作用域  1、next 改为箭头函数  2、用this.  找顶层作用域
```js
const iterableObj = {
  names: ["abc", "cba", "nba"],
  [Symbol.iterator]: function() {  //不是当属性用 所以是中括号意思是可计算属性
    let index = 0
    //2、这里的this  也就是iterableObj
    return {
      next: () => {  //1、这个this 是
        if (index < this.names.length) {
          return { done: false, value: this.names[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
}


// 传统遍历写法   但一般不这么写 太麻烦了
const iterator = iterableObj[Symbol.iterator]()
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

//for...of    替代传统遍历写法
 for (const item of iterableObj) {
  console.log(item)
 }
```
#### 自定义迭代 类
```js
任务
1、创建一个classrom类
2、教室中有自己的位置、名称、当前教室的学生
3、这个教室可以进来新学生
4、创建的教室对象是可迭代对象
class Classroom {
  constructor(address, name, students) {
    this.address = address
    this.name = name
    this.students = students
  }
  entry(newStudent) {
    this.students.push(newStudent)
  }

  [Symbol.iterator]() {
    let index = 0
    return {
      next: () => {
        if (index < this.students.length) {
          return { done: false, value: this.students[index++] }
        } else {
          return { done: true, value: undefined }
        }
      },
      return: () => {
        console.log("迭代器提前终止了~")
        return { done: true, value: undefined }
      }
    }
  }
}

  
const classroom = new Classroom("3幢5楼205", "计算机教室", ["james", "kobe", "curry", "why"])

classroom.entry("lilei")

for (const stu of classroom) {
  console.log(stu)
  if (stu === "why") break
}

```


### 生成器 基于迭代器（衍生的）
	目的：在执行的过程中暂停和恢复的流程。而return 无法做到。
		生成器可以替代迭代器。
	引入生成器函数概念：
		1、function 后面加 * 
		2、用上 yeield 关键字。
		3、返回值是 Generator生成器， 用  .next() 执行。 调用一次执行一截，反复
		4、用 return 可以提前终止运行
		5、yeield当作有记忆的效果，缓存了上一次运行的结果
**生成器替代迭代器使用**
1、遍历简化写法
	3 -> 2->1  三种都是一样效果。
```js
function* createArrayIterator(arr) {
 
  // 3.第三种写法 yield*
  yield* arr

  // 2.第二种写法
  for (const item of arr) {
    yield item
  }

  // 1.第一种写法
  yield "abc" // { done: false, value: "abc" }
  yield "cba" // { done: false, value: "abc" }
  yield "nba" // { done: false, value: "abc" }
}

const names = ["abc", "cba", "nba"]
const namesIterator = createArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
```
2、根据有记忆的特性，实现区间内的值
```js
function* createRangeIterator(start, end) {
  let index = start
  while (index < end) {
    yield index++
  } 
}
  
const rangeIterator = createRangeIterator(10, 20)
console.log(rangeIterator.next())  
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())

/*
{ value: 10, done: false }
{ value: 11, done: false }
{ value: 12, done: false }
{ value: 13, done: false }
{ value: 14, done: false }
*/
```
3、class 用上生成器 
```js
class Classroom {
  constructor(address, name, students) {
    this.address = address
    this.name = name
    this.students = students
  }

  entry(newStudent) {
    this.students.push(newStudent)
  }
	//变量存储 函数
  foo = () => {
    console.log("foo function")
  }

  // [Symbol.iterator] = function*() {
  //   yield* this.students
  // }

  *[Symbol.iterator]() {
    yield* this.students
  }
}

const classroom = new Classroom("3幢", "1102", ["abc", "cba"])

for (const item of classroom) {
  console.log(item)
}
/*
abc   cba
*/
```
#### 忘记了看这个理解
模板
	返回参数基于 迭代器   done、value
	yield 是暂停类似单片机的中断器（done: false）， return 是结束（即done: true）
传递参数
	通过第一段 yield   的结果 传给第二段的 yield
	每个参数  对应一个yield 
```js

function* foo(num) {
  console.log("函数开始执行~")

  const value1 = 100 * num
  console.log("第一段代码:", value1)
  const n = yield value1   // 第一次 .next()执行结束

  //generator.return(15)  相当于 是 return 15

  const value2 = 200 * n
  console.log("第二段代码:", value2)
  const count = yield value2  // 第二次 .next()执行结束

  const value3 = 300 * count
  console.log("第三段代码:", value3) 
  yield value3 
  try {
	    yield value3   // 第三次 .next()执行结束
	} catch (error) {
		console.log("捕获到异常情况:", error)
		yield "abc"
	}

  console.log("函数执行结束~")
  return "123"// 第四次 .next()执行结束   
}

// 生成器上的next方法可以传递参数
const generator = foo(5)  //num   500
console.log(generator.next())

// 第二段代码, 第二次调用next的时候执行的
//console.log(generator.return(15))  //意思是直接立即终止
console.log(generator.next(10))  // n    2000

//generator.throw("error message")   //意思是 报错则 返回"abc"
console.log(generator.next(25))  //count  7500

```
 
	
``
``








### class 类 es6 （2015）废弃构造函数方式写类
	总结： class 还是基于构造函数、原型链 衍生出类的概念和继承。
	区别： 
	1、括号：function有括号可以直接传递参数， 而class是用 constructor() 来传递参数。
	2、继承：比构造函数好写继承，class 用关键字extends 表示继承
	
#### 忘记了看这里理解
##### 1、区别code：
	es6前是构造函数方式new创建类  看起来跟function 过于相似。es6后就有class 关键字来写类
```js
//构造函数创建 类 和传参     es6后不用这么写
fucntion Person(name,age){ }
var p1 =new Person("why");


// class 关键字 创建类 和传参    es6后这么写
class Person {
// 不是 prototype 的constructor 是外部调用时，内部会执行这个方法。
  constructor(name, age) {  
    this.name = name
    this.age = age
  }
}
var p1 = new Person("why", 18)
var p2 = new Person("kobe", 30)
console.log(p1, p2)

```
##### 2、class写法code分：类声明、类表达式
```js
// 写法1、类的声明
class Person {  //声明的时候就出现prototype  }

// 写法2、类的表达式
var Animal = class {  }


声明class Person { } 后拥有prototype：
	prototype //是{ }有两个属性
	{
		constructor //是指向  声明 class Person{//声明的时候就出现prototype  }
		__proto__  //是指向 null
		{
			constructor:{}
			hasOwnProperty()
			isPrototypeOf()
			propertyIsEnumerable()
			toLocaleString()
			toString()
			valueOf()
			get()
			set()
		}
	}
	
```
##### 3、特性备忘
```js
var p = new Person() //__proto__

得出： __proto__  ->  prototype   
所以： console.log(p.__proto__ === Person.prototype) // true
 
```







#### 方法-示例写法
	class 具有几个方法概念: 
		普通方法（先new），访问器方法（先new），静态方法（无需new）少见。
```js
var names = ["abc", "cba", "nba"]

class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
    this._address = "广州市"
  }

  // 普通的实例方法
  // var p = new Person();  p.eating();
  eating() {
    console.log(this.name + " eating~")
  }
  running() {
    console.log(this.name + " running~")
  }

  // 类的访问器方法
  get address() {
    console.log("拦截访问操作")
    return this._address
  }
  set address(newAddress) {
    console.log("拦截设置操作")
    this._address = newAddress
  }

  
  // 类的静态方法(类方法)
  // Person.createPerson()
  static randomPerson() {
    var nameIndex = Math.floor(Math.random() * names.length)
    var name = names[nameIndex]
    var age = Math.floor(Math.random() * 100)
    return new Person(name, age)
  }
}


var p = new Person("why", 18)  //普通的实例方法  访问器方法
p.eating()
p.running() 
console.log(p.address)  
p.address = "北京市"    
console.log(p.address)


for (var i = 0; i < 50; i++) {
  console.log(Person.randomPerson())  //静态方法
}

```

#### 继承-示例写法
	调用父类关键词super.  ，继承关键词extends  。
	相当于 Student.__proto__  -> Person.prototype ,new Student 后
	__proto__ -> person.prototype
```js
class Student extends Person {
  // 那么子类的构造方法中, 在使用this之前
  constructor(name, age, sno) {
    super(name, age)
    this.sno = sno
  } 
  studying() {
    console.log(this.name + " studying~")
  } 
  
  // 类对父类的方法的重写
  running() {
    console.log("student " + this.name + " running")
  } 
  // 重写personMethod方法
  personMethod() {
    // 复用父类中的处理逻辑
    super.personMethod()
    console.log("处理逻辑4")
    console.log("处理逻辑5")
    console.log("处理逻辑6")
  }
  // 重写静态方法
  static staticMethod() {
    super.staticMethod()
    console.log("StudentStaticMethod")
  }
}

var stu = new Student("why", 18, 111)
console.log(stu)
stu.eating()
stu.running()
stu.personMethod()

Student.staticMethod()

```
#### 多态  （以面向封装接口的角度看待）
	不同数据类型进行同一个操作，表现出不同行为。
	表现：必须继承、重写父类方法、父类引用指向子类对象。
	理解：
		教室看作接口函数，一群学生看作是子类，试卷看作是父类， 当调用接口函数时，学生作为参数，同一个试卷得出多种答案。
		说白了就是 写死接口函数的逻辑，那么就相当于固定了函数名变量名，用子类重写父类，就可以修改外部逻辑，接口内部根据外部逻辑来执行出不同的结果。用的时候调用接口函数，实例化子类当参数。
		举个例子
```js
// 也是多态的体现
function sum(m, n) {
  return m + n
}

sum(20, 30)
sum("abc", "cba")

只管调用接口、和传入参数。 不去干预接口都会正常的跑且根据参数来得出对应的结果。
```

### es6-12部分 都是提高简写代码的东西
	看实现原理 用 babeljs.io ->Try it out 
#### 1、字面量增强  官方叫法Enhanced object literals
	目的：说白了就是增加了对象写代码时一些可以简写写法。
	 property shorthand(属性的简写)    属性声明简写写法
	 method shorthand(方法的简写)   方法简写写法
	 computed property name(计算属性名)    说白了是加属性简写写法
```js
var name = "why"
var age = 18

  
var obj = {
  name:name,
  age:age,
}
用到了 全局的且名称相同 那么简写
var obj = {
  // 1.官方叫法 property shorthand(属性的简写)
  name,
  age,
}

var obj = { 
  // 2.官方叫法method shorthand(方法的简写)
  foo: function() {  //以前写法
    console.log(this)  
  },
  bar() {   //es6 简写写法
    console.log(this)
  },

  baz: () => {   // 这个是箭头 作用域不同前面两种有区别的。
    console.log(this)     
  },

  
  // 3.官方叫法computed property name(计算属性名)
  [name + 123]: 'hehehehe'
}
 

3、 原本以前加属性是这样写
obj[name + 123] = "hahaha"  //  obj.name213:"hahaha"



```
#### 2、解构
	数组有序（原理下标）， 对象无序（原理key）
	对象 更常用 函数返回值。
##### 2.1、数组-解构
	以前只能通过 下标去解构
```js
var names = ["abc", "cba", "nba"]
var [item1, item2, item3] = names  //全部解构
var [, , itemz] = names // 只解构 nba   比较少用
var [itemx, ...newNames] = names  // 解构出一个元素,后面的元素放到一个新数组中
var [itema, itemb, itemc, itemd = "aaa"] = names // 默认值
```
##### 2.2、对象-解构
	跟 数组差不多  只是 用{}
```js
// 2.对象参数和默认值以及解构
function printInfo({name, age} = {name: "why", age: 18}) {
  console.log(name, age)
}
printInfo({name: "kobe", age: 40})


// 另外一种写法
	// 这种就是说 当无参数即空对象时，默认值生效
function printInfo1({name = "why", age = 18} = {}) {
  console.log(name, age)
}
printInfo1()

```
#### 3、const
	与window关系理解：创建的执行上下文叫VE  在具体实现的时候这个v8引擎是用到hashmap 保存变量，查找也是从数据结构去查找。
	const/let  声明后不可重复声明， 无作用域提升。
	const 不可变更。
	
#### 4、块作用域
	对象声明是对象声明， 块作用域是块作用域， 函数作用域是函数作用域。 不是一个东西
	虽然都是用{ }
	函数作用域是 链式查找，一层层往外找， 而外部找不到里面。
	{}内写let 会限制仅{}内有效，而var不会限制会跑到全局。
	不同的浏览器有不同实现的(大部分浏览器为了兼容以前的代码, 让function是没有块级作用域)
	if、switch、for 就是 块作用域规则。遵守块作用域的声明类型规则
	什么时候用从const
		for(const item of names) 仅遍历用const。
	什么时候用let
		for(let i=0; i<2;i++) 涉及变化用let。
	
**模板**
```js
// 对let/const/function/class声明的类型是有效
{
  let foo = "why"
  function demo() {
    console.log("demo function")
  }
  class Person {}
}

console.log(foo) // foo is not defined
demo()   //能不能访问 看不同浏览器 有的可以有的不可以 为了兼容
var p = new Person() // Person is not defined

//i 是独立的两个
{
	let i =1;
}
{
	let i =2;
}
//i 是同一个i 
{
	var i =1;
}
{
	var i =2;
}
```
**应用场景**
常见 for 遍历事件时候，i 遍历结束都会是最后一个。作用域块问题。
原因分析：
	for(var i){}  则 没有形成块作用域， i跑全局 导致i 串扰
	for(let i){}  则形成块作用域 ， i 尽在{} 内有效 不导致i 跑全局不串扰
解决办法：
	早期因为没有块级作用域，用闭包作用域规则，保存i。
	现在有let 用let 形成块作用域。
	不用const 是因为 const无法修改，虽然也形成块作用域。
```js

const btns = document.getElementsByTagName('button')
//下面写法等效  
//es6之前  没有块级作用域，立即执行 闭包传递i，不拿全局i
 for (var i = 0; i < btns.length; i++) {
  (function(n) {
     btns[i].onclick = function() {
      console.log("第" + n + "个按钮被点击")
    }
   })(i)
}

// console.log(i)

  
//es6 现在有let 用let 形成块作用域。
for (let i = 0; i < btns.length; i++) {
  btns[i].onclick = function() {
    console.log("第" + i + "个按钮被点击")
  }
}
// console.log(i) 
```
**暂时性死区示例**
```js
var foo = "foo" 
if (true) { 
   console.log(foo)  //报错  foo 既不是 全局 也暂时不是 abc
   let foo = "abc"
}
```
 
#### 5、标签模板字符串
	react 常见这种 框架提供了函数 ，code 这样去传参
	react 以 all in js 风格  如： styled-compinents库 把动态值做css的参数就用到这种标签模板字符串写法。
```js
function foo(m, n, x) {

  console.log(m, n, x, '---------')

}
foo("Hello", "World")

// 另外调用函数的方式: 标签模块字符串
foo``

const name = "why"
const age = 18
//输出 ['Hello', 'Wo', 'rld'] why 18 ---------
foo`Hello${name}Wo${age}rld`
```
#### 6、函数
##### 默认参数
**一、解决  早期缺陷的写法。**
```js
function foo(m, n) {
  m = m || "aaa"
  n = n || "bbb"
  console.log(m, n)
}

foo(0,"");  
//故意给这种参数 代码应当执行 m =0; n="";  但由于逻辑或操作 会使得m="aaa"; n="bbb";

```
**二、有默认值的形参，放最后写**
```js
// 默认值写前面，采用默认值得这么写
function bar(x = 30, y, z) {
  console.log(x, y, z)
}
bar(undefined, 10, 20)  // 正确写法  30，10，20
bar( , 10, 20)   // 错误写法

// 上面写法太啰嗦，所以默认值写最后面， 可以这样简写
function bar(y, z, x = 30) {
  console.log(x, y, z)
}
bar(10, 20) // 10,20,30
```
**三、有默认值的形参，不计算在length属性内(了解扩展)**
```js
function bar(x, y, z, m, n = 30) {
  console.log(x, y, z, m, n)
}
console.log(bar.length) //4   
```
##### 剩余参数
	官方叫rest parameter, 目的平替早期的arguments 数组。
	原因： rest 是真数组， arguments 是伪数组
	最后一个 参数 ...为前缀， 把剩余参数全push 进数组。
```js
 function foo(...args, m, n) {
   console.log(m, n)
   console.log(args)
   console.log(arguments)
 }
 foo(20, 30, 40, 50, 60)
```
#### 7、扩展运算符
	字符串每个字符分割成一个个体。
一、常规 函数调用 
```js
const names = ["abc", "cba", "nba"]
const name = "why"
const info = {name: "why", age: 18}
// 1.函数调用时
function foo(x, y, z) {
  console.log(x, y, z)
}

//简化写法
foo.apply(null, names) // abc cba nba
foo(...names)  // abc cba nba
foo(...name) // w h y
```
二、构造数组
```js
const names = ["abc", "cba", "nba"]
const name = "why"
const info = {name: "why", age: 18}

const newNames = [...names, ...name]
console.log(newNames) //[ 'abc', 'cba', 'nba', 'w', 'h', 'y' ]
```
三、构建对象
	对象具有浅拷贝效果，开辟新空间，存储原本的地址
```js
const names = ["abc", "cba", "nba"]
const name = "why"
const info = {name: "why", age: 18}

const obj = { ...info, address: "广州市", ...names }
console.log(obj)
/*输出
{
  '0': 'abc',
  '1': 'cba',
  '2': 'nba',
  name: 'why',
  age: 18,
  address: '广州市'
}
*/
```
#### 超大数值(拼接)连接符 （了解扩展） && BigInt
	目的：方便阅读而已。
```js
const num = 10_000_000_000_000_000
console.log(num)  //10000000000000000
```
	早期最大值时候 做加法会不准确 出现异常计算，es11后 用BigInt 解决。
```js
const maxInt = Number.MAX_SAFE_INTEGER
console.log(maxInt) // 9007199254740991


const bigInt = 900719925474099100n
console.log(bigInt + 10n) //900719925474099110n

const num = 100
console.log(bigInt + BigInt(num)) //900719925474099200n

const smallNum = Number(bigInt)
console.log(smallNum) //900719925474099100
```

#### 8、Symbol （可以当c的枚举判断条件用，优化代码时候用解耦合）
	symbol 也是一种基本数据类型 如 string、number、arrary。
	针对对象键值对的严格模式，不再用普通对象：增、遍历的操作。
	目的：避免不同对象的 属性同名冲突。
	Object.keys()
	Symbol.for() 相当于不太严格的 symbol  可修改的symbol
	Symbol.keyFor()
**基础认识**
```js
// 每个Symbol 是不同的区域
const s1 = Symbol()
const s2 = Symbol() 
console.log(s1 === s2)  //false

// 通过描述符进行 备注
const s3 = Symbol("aaa")
console.log(s3.description) 

// Symbol.for() 先检查，不存在则创建。且返回值
const s1 = Symbol.for('aaa')
const s2 = Symbol.for('aaa') 
console.log(s1 === s2)  //true


//Symbol.keyFor() 返回一个已登记的Symbol类型
let s1 =Symobl.for('aaa');
let s2 =Symobl.keyfor(s1);
console.log(s2);// aaa
let s3 =Symobl('bbb');
let s4 =Symobl.keyfor(s3);
console.log(s4);// undefined

// 打印只能obj[] 无法obj.操作
console.log(obj[s1], obj[s2], obj[s4]，obj(s5))
```
**常规定义**
```js
// 常规定义 两种 
	//Symbol.for()全局环境中 
	//Symbol() 不在全局环境 属于独一无二
//1、Symbol()
const s1 = Symbol()
const s2 = Symbol()
const obj = {
  [s1]: "abc",
  [s2]: "cba"
}

// 2、Symbol.for()
s3= Symbol.for("abcd")
obj[s3] = "abcd"

// 新增属性写法 两种
// 1、Symbol
const s4 = Symbol()
obj[s4] = "nba"

// 2、通过Object。defineProperty() 
const s5 = Symbol()
Object.defineProperty(obj, s5, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "mba"
})
```
**常规遍历**
```js
// 遍历属性写法 通过Object.getOwnPropertySymbols( )
const sKeys = Object.getOwnPropertySymbols(obj)
for (const sKey of sKeys) {
  console.log(obj[sKey])
} 
```
**实际场景解耦合 obj 可以封装到独立的文件**
```js
let obj ={
	type1:Symbol('one'),
	type2:Symbol('two'),
	type3:Symbol('three'),
	type4:Symbol('four'),
}
fucntion test(param){
	switch(param){
		case obj.type1:
			...
			break;
		case obj.type2:
			...
			break;
		case obj.type3:
			...
			break;
		case obj.type4:
			...
			break;
	}
}
```

#### 9、Set  （针对数组即基本类型） 
	是一种数据结构，
		对数组 增删查方法进行一种封装 快捷方法。
		对像 
	区别： 
		Set 不允许数据重复。 Array 允许数据重复。
	set 也是一个类常用的方法： add() size() clear() has() 。
**数组-基本用法**
```js
const arr = [33, 10, 26, 30, 33, 26]
const arrSet = new Set(arr)

// 查看大小默认去重
console.log(arrSet.size) //4

// 新增属性
arrSet.add(100)
console.log(arrSet) //Set(5) { 33, 10, 26, 30, 100 }

// 删除
arrSet.delete(33)
console.log(arrSet) //Set(4) { 10, 26, 30, 100 }

// 清空
arrSet.clear()
console.log(arrSet) //Set(0) {}

// 判断100是否存在
console.log(arrSet.has(100)) //true

// 遍历
arrSet.forEach(item => {
  console.log(item)
})

for (const item of arrSet) {
  console.log(item)
}
```
**对象-基本用法**、
	主要在地址
```js
const set = new Set()
set.add({}) // 0x0000
set.add({}) // 0x0001

//这样 是处理同一个对象
const obj = {} // 0x0000
set.add(obj) // 0x0000
set.add(obj) // 0x0000
```
**实际场景**
	任务：用Set 快速数组去重
	
```js
const arr = [33, 10, 26, 30, 33, 26]
const arrSet = new Set(arr)
console.log(arrSet)  // Set(4) { 33, 10, 26, 30 }

如果用数组自己方法去重比较麻烦
const newArr = []
for (const item of arr) {
  if (newArr.indexOf(item) !== -1) {
    newArr.push(item)
  }
}

```

#### 10、WeakSet (针对对象即引用类型)别的语言比较常见
	目的：写一些比较严谨的类时候用。
		如：控制this 是实例化对象才可操作。无法通过call改变this指向来间接调用类方法。
		因为: 销毁机制，GC是否销毁，会受到开辟的空间指向干扰。
	区别Set:
		1、只能对象类型
		2、相对 Set  set是强引用，  weakset是弱引用。
得先理解
	就是V8引擎  谁管理this    能找到就是会被指向  ，没指向被GC垃圾回收器回收。
	VE （variables_）    如let const 就是 在 ve   由v8管理
	VO->GO   var 就是在vo   由浏览器管理
	GC 会不定时去看 是否有人指向在使用没有则直接回收销毁。
		VE是不会被回收， 一个对象是一个空间  套娃对象是存对象地址。
		当套娃对象 的值（地址） 为 null ，则被回收断开指向。
		当外层对象 地址为 null, 则全部回收断开指向。 
		多指向时称为 强引用 strong reference 。
		弱引用 weak reference 。当只有一条引用的时候，GC判断无法判断弱引用是引用会被GC回收销毁。
	使得 让一个引用变为弱引用，就会被回收。
	引用就是可以 .操作获取。因为是靠地址指向。
**大概指向理解**
		还是上下文分配空间理解，水平不够只能强制这么理解。
```js
new Set()
	内存是这样分配的：
	let obj ={ name: "why"}     
		// 上下文{obj:0x100 } -> obj对象空间0x100{  name:"why"};
	const set = new Set()    
		//上下文{set:0x200 }
	set.add(obj)   
		//上下文{set:0x200 } -> set对象空间0x200{ xxx:0x100} -> obj对象空间0x100   
	obj =null 
		// 上下文{obj:null }      
		// 则obj 不指向 obj对象空间0x100, 但是obj对象空间0x100不销毁。因为 set在指向。

 new WeakSet()
	 内存是这样分配的：
	let obj ={ name: "why"}     
		//上下文{obj:0x100 } -> obj对象空间0x100{  name:"why"};
	const weakSet = new WeakSet()    
		//上下文{weakSet:0x200 }
	weakSet.add(obj)   
//上下文{weakSet:0x200 } ->weakSet对象空间0x200{ xxx:0x100} -> obj对象空间0x100
	obj =null  
		// 上下文{obj:null }  
		//上下文{set:0x200 } -> set对象空间0x200{ xxx:null}
		//则obj 不指向 obj对象空间0x100, weakSet是弱应用 断开不指向 obj对象空间0x100
```

#### 11、Map
	把对象当作对象key的过程叫 ：存储映射关系。
	常规能用对象做key其实是做了一次转换，才可以把对象做key，但是实际场景中根本无法使用。
	而Map 是 可以把对象做key。
**普通对象把对象做key，实际上是转为了 字符串"[object object]" 来做key 所以才可以这样操作。对象无法用对象做key。**
	所以出现了Map  把对象 当作对象的key操作
```js
//串扰了
const obj1 = { name: "why" }
const obj2 = { name: "kobe" }
const info = {
  [obj1]: "aaa",  //[object object] :  "aaa"
  [obj2]: "bbb"  //[object object] :  "bbb"
 }

 console.log(info) //{[object Object]: 'bbb'}
```
**基本操作**
```js
1、set方式 加 键值对
const map = new Map()
map.set(obj1, "aaa")
map.set(obj2, "bbb")
map.set(1, "ccc")
console.log(map)

2、 参数方式 加 键值对
const map2 = new Map([[obj1, "aaa"], [obj2, "bbb"], [2, "ddd"]])
console.log(map2)

/*输出
Map(3) {
  { name: 'why' } => 'aaa',
  { name: 'kobe' } => 'bbb',
  1 => 'ccc'
}

*/
```
	map 也是一个类常用的方法： add() size() clear() has() 。
**对象-基本用法**
```js
const map2 = new Map([[obj1, "aaa"], [obj2, "bbb"], [2, "ddd"]])

// 查看大小默认去重
console.log(map2.size)
// 新增
map2.set("why", "eee")
console.log(map2)

// 获取
console.log(map2.get("why"))

// 判断
console.log(map2.has("why"))

// 删除
map2.delete("why")
console.log(map2)

// 清空
map2.clear()
console.log(map2)

// 遍历map
map2.forEach((item, key) => {
  console.log(item, key)
})
for (const item of map2) {  // item是数组 下标获取写法
  console.log(item[0], item[1])
}

// 遍历map 推荐 更高级的感觉用上了解构
map2.forEach((item, key) => {
  console.log(item, key)
})
for (const [key, value] of map2) {  //[key, value]是 item是数组[]， 解构式写法
  console.log(key, value)
}
```
#### 12、WeakMap （弱引用）
	区别Map:
		1、key只能对象类型
		2、无 size() 方法
		3、无法遍历
**应用场景vue3响应式**
	改变obj1时，执行某几个监听函数，改变obj2时，执行某几个监听函数
	
```js
// 1.创建WeakMap
const weakMap = new WeakMap()

// 2.收集依赖结构
// 2.1.对obj1收集的数据结构
const obj1Map = new Map()
obj1Map.set("name", [obj1NameFn1, obj1NameFn2])
obj1Map.set("age", [obj1AgeFn1, obj1AgeFn2])
weakMap.set(obj1, obj1Map)

// 2.2.对obj2收集的数据结构
const obj2Map = new Map()
obj2Map.set("name", [obj2NameFn1, obj2NameFn2])
weakMap.set(obj2, obj2Map)

  
// 3.如果obj1.name发生了改变
// Proxy/Object.defineProperty
obj1.name = "james"
const targetMap = weakMap.get(obj1)
const fns = targetMap.get("name")
fns.forEach(item => item())
```
#### 13、flat （付磊特） 扁平降维
```js
const nums = [10, 20, [2, 9], [[30, 40], [10, 45]], 78, [55, 88]]
const newNums = nums.flat() // 降一次维

console.log(newNums) //[ 10, 20, 2, 9, [ 30, 40 ], [ 10, 45 ], 78, 55, 88 ]

//继续扁平化 要么再绛一次
const newNums2 = newNums.flat()

//要么传递参数绛维
const newNums = nums.flat(2)  //降两次 

/* 输出
[
  10, 20,  2,  9, 30,
  40, 10, 45, 78, 55,
  88
]
*/
```
#### 13、flatMap 
	参数一  函数
	参数二  绑定this
**使用场景**
	把每个空格分隔的字符 都取出来
```js
const messages = ["Hello World", "hello lyh", "my name is coderwhy"]
const words = messages.flatMap(item => {
  return item.split(" ")
}) 
console.log(words)
/*输出
[
  'Hello', 'World',
  'hello', 'lyh',
  'my',    'name',
  'is',    'coderwhy'
]
*/

相当于 然后flat后 降维了。
[
  ['Hello', 'World'],
  ['hello', 'lyh'],
  ['my',    'name'],
  ['is',    'coderwhy']
] 
```

#### 14、FinalizationRegistry
	垃圾回收后触发执行的函数,用于检测是否被回收，测试 强弱引用。
	参数一 对象，  参数二 类似注释参数
```js
const finalRegistry = new FinalizationRegistry((value) => {
  console.log("注册在finalRegistry的对象, 某一个被销毁", value)
})

let obj = { name: "why" }
let info = { age: 18 }

finalRegistry.register(obj, "obj")
finalRegistry.register(info, "value")

obj = null
info = null
//浏览器运行 一会 等gc 不定时销毁后才会执行
```

#### 15、 WeakRef  弱引用
	专门拿来创建弱引用的对象
```js
// ES12: WeakRef类
// WeakRef.prototype.deref:
// > 如果原对象没有销毁, 那么可以获取到原对象
// > 如果原对象已经销毁, 那么获取到的是undefined
const finalRegistry = new FinalizationRegistry((value) => {
  console.log("注册在finalRegistry的对象, 某一个被销毁", value)
})

let obj = { name: "why" }
let info = new WeakRef(obj)

finalRegistry.register(obj, "obj")
obj = null

//用 延时是 等待gc不定时 销毁后执行 测试
setTimeout(() => {
  console.log(info.deref()?.name)
  console.log(info.deref() && info.deref().name)
}, 10000)

```




## 没资料部分

### 错误处理方案
	调用函数 ->参数类型不匹配，需要去干预规避编译自动处理。
#### 解决办法：
	不用 return ,用 throw 提示用户类型错误。
```js
// 正常情况下 编译时 ， 参数一强转为字符串。

function sum(num1,num2){
	if(typeof num1 !== "number" || typeof num2 !== "number"){
		throw "parameters is error type~"
	}
	return num1 +num2
}

console.log(sum({ name: "why"},true));
```
#### 补充 throw 一般抛出对象
区别： 官方报错信息更多方便调试，采用了调用栈技术。
场景： 自定义函数时候用官方，  请求服务器用自定义 Error 类

	自定义对象
```js
class HYError {
	constructor(errorCode, errorMessage) {
		this.errorCode = errorCode
		this.errorMessage = errorMessage
	}
}
function sum(type){
	if(type === 0){
		 
		// throw { errorCode: -1001, errorMessage:"type 不能为0~"}
		throw new HYError(-1001, "type 不能为0~")
	} 
}
console.log(sum());
```
	采用官方
```js
function sum(type){
	if(type === 0){
		  
		throw new Error("type 不能为0~")
	} 
}
console.log(sum());
```
#### 处理抛出 嵌套调用时候。
```js
function foo(){
	throw new Error("foo error message~");
}
function bar(){
	try{
		foo(1)
	}catch(err){   // 不用err, 可以简写 catch{ }。
		//err 是 "foo error message~"  
		
	} finally{
		//提供了finally无论成功、失败，都会执行。
		
	}
}
bar();
```

### JSON
	js对象的符号 不等于 对象,算是js的一个子集。是因为最初json 被应用与 js为主。其他都能将json 转为自己的对应模型。
	起源:
		XML  解析比较麻烦，传输不方便。
		Protobuf 网络传输中比较常用（直播），2021年开始支持js了。
	场景:
		http 、 配置文件 、 非关系型数据库。
	值类型:
		 Number、 String不支持单引号、 boolean 、	null
		{ "": ""}    key必须带双引号
		[ ]	  
	 注意：
			 JSON不能写注释，最后项不能加逗号 。
```js
[
	123,
	"abc",
	{
	  "name":"boke"
	}
]

```
#### JSON序列化
不要把对象直接存到 localStorage  会被强制转为字符串[object Object] 
```js
const obj ={ 
    name:"why",
    age:18,
    friends:{
        name:"kobe"
    },
    hobbies:["篮球","足球"]
}

// 转为JSON格式的字符串
const objString = JSON.stringify(obj);
// 将对象数据存储localStorage
localStorage.setItem("obj",objString)

const jsonString = localStorage.getItem("obj");
// 将JSON格式的字符串转回对象
const info =JSON.parse(jsonString)
console.log(info)
```
##### stingify 方法细节
```js
const obj = {
    name: "why",
    age: 18,
    friends: {
        name: "kobe"
    },
    hobbies: ["篮球", "足球"],
    toJSON: function () {
        return "所有stringify 都会执行toJSON"
    }
}

// 需求：转为JSON格式的字符串
// 1.直接转换
const jsonString1 = JSON.stringify(obj);
console.log(jsonString1)

  
// 2.stringify参数二  replacer
// 2.1. 传入数组：设定哪些是需要转换
const jsonString2 = JSON.stringify(obj, ["name", "friends"]);
console.log(jsonString2)


// 2.2 传入回调函数：  
const jsonString3 = JSON.stringify(obj, (key, value) => {
    if (key === "age") {
        return value + 1
    }
    return value
});
console.log(jsonString3)

  
// 3.stringify参数三  space
// 3.1 相当于换行格式化： 数字:就是顶行前面几个空格， 字符串: 就是显示字符串内容 。
const jsonString4 = JSON.stringify(obj, null, 4);
console.log(jsonString4)

  
// 4.如果obj对象中有toJSON方法
// 4.1 所有的stringify 都会强制执行这个toJSON导致改变了结果
```

##### JSON字符串解析 parse细节
```js
const JSONString = '{"name":"why","age":18,"friends":{"name":"kobe"},"hobbies":["篮球","足球"]}'

const info = JSON.parse(JSONString,(key, value) => {
    if(key === "age"){
        return value -1
    }
    return value
})
console.log(info)

/*
{
    age: 17,
    friends: {name: 'kobe'},
    hobbies: ['篮球', '足球'],
    name: "why",
}
*/
```

##### JSON序列化实现 -深拷贝
	 浅拷贝：当 {}内有{},则内部对象不是拷贝而是引用。导致串改 内部对象的值。 
	 深拷贝：{}内的{}也拷贝，实现完全分离，不会串改。
	 但是得考虑，内部是函数，由于JSON内不允许函数存在，函数会在转换过程中自动删除。所以json 只能实现无函数的深拷贝。
```js
const obj = {
    name: "why",
    age: 18,
    friends: {
        name: "kobe"
    },
    hobbies: ["篮球", "足球"]
}

const jsonSting = JSON.stringify(obj)
console.log(jsonSting)
const info3 = JSON.parse(jsonSting)
obj.friends.name= "curry"
console.log(obj.friends.name)
console.log(info3)
```





### 浏览器存储机制  (WebStorage)
	 localStorage  持久存储
	 sessionStorage  本次会话临时存储,也不跨新页面
```js 
localStorage.setItem("name","localStorage")
sessionStorage.setItem("name","sessionStorage")

//localStorage 方法
// 1.setItem
localStorage.setItem("name", "localStorage")
localStorage.setItem("age", 18 )

// 2.length
console.log(localStorage.length)
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i)
    console.log(localStorage.getItem(key))
}

// 3.key方法
console.log(localStorage.key(0))
  
// 4.getItem(key)
console.log(localStorage.getItem("age"))

// 5.removeItem
localStorage.removeItem("age")

// 6.clear方法
localStorage.clear()
```
	认识 IndexdDB  是事务型数据库
完成则全部完成，没完成则全部撤销。


### BOM
	js得通过 BOM  才能操作浏览器。
#### 1、Cookie
```js
请求  request headers 
返回  response headers 携带 set-cookie 
请求  request headers  携带cookie 给serve

生命周期
	expires    生效时间
	max-age    过期时间     60*60*24*365
	Domain   不指定，默认 origin，不包括子域名
		指定Domain ，则包含子域名。 Domain= mozilla.org
		则 Cookie也包含子域名   developer.mozilla.org 

浏览器删cookie只能通过设置过期时间。强制失效删除，前提是服务端设置HttpOnly=false 才可以（服务需要重启才生效）
document.cookie ="name=why;max-age=0"


cookie附加在域名中，每次请求都携带，废流量。 大小限制4kb,主要是移动端不方便 不一定是浏览器没法携带cookie 给服务器。

用token 替代 cookie

```
#### 2、BOM
	浏览器 封装了很多的对象模型，用来js 与浏览器交互。
	window    控制浏览器窗口的相关属性
	location  记录url 
	history   操作浏览器的历史  
	document   当前窗口操作文档的对象
window分 两种身份
一 作为js的全局对象  GO
二 浏览器窗口对象  : 属性、方法 、事件 ，还继承EventTarget 方法 。
```js
//EventTarget 在 window 的3次继承上
console.log(window.__proto__.__proto__.__proto__)

// 属性
window.screenX
window.screenY

window.addEventListener("scroll",() =>{
	console.log(window.scrollX, window.scrollY)
})

window.outerHeight  // 浏览器整个高度
window.innerHeight  // 浏览器工作视图高度

// 方法
location.assign("http://www.baidu.com")  带回退功能跳转
location.replace("http://www.baidu.com")  清除路由记录跳转 无法回退了
location.reload( )   重载页面


cosnt jumpBtn = document,querySelector("#jump")
jumpBtn.onclick = function(){

	跳转不刷新页面：history.pushState
	//   参数  ，title ，路径
	// 目前不支持title了，被禁废弃了
	//参数name 可以通过 history.state 获取
	history.pushState({name:""},"","/detail")
}
```



## 项目开始
### JS模块化分析  
	规范只是定义代码如何导入导出。 
	面试只看  2、3、6   复习 按1-6来看怎么演变的。
	6是重点 尤其在刚接触别人代码的时候很迷，看了6就清晰了。
#### 1、文件导入导出，CJS规范
##### 忘记了看这个理解
	早期这么写，用function 作用域隔离，避免多文件冲突变量名。
	缺点：不通用，于是出现 CommonJS规范、AMD(弃用)、CMD(弃用)、ES Module 。
```js
kobe/index.js
var moduleKobe= (function(){
	var name ="kobe"
	var isFlag= false  
	 return {
		 name: name,
		 isFlag: isFlag
	}
 })()
 
why/index.js
(function(){
	 if(moduleKobe.isFlag){
		 console.log("我的名字是" + moduleKobe.name)
	 }
 })()

html
	<script src="kobe/index.js"></script>
	<script src="why/index.js"></script>
```
##### webapack、Node 都采用CJS规范
	exports、 module.exports 、require 
	require 时,  .js 可以省略， 会自动轮询加后缀。
	导入的文件尽可能不去变更导出文件。
	基本废弃用exprots 做导出，改用module.exprots={}
```js
// exports 导出 
//exports={ } 不能导出对象  因为源码 module.exports ={}  exports = module.exports
exports.name ="xxx";    单独导出某个属性
//引入
const modulea = require("./xxx.js")
module.names


// module.exprots 导出 
module.exprots={
	names,
	age,
	sum
}

//引入
const modulea = require("./xxx.js")
module.names
//引入
const {names,age} = require("./xxx.js")


// module.exprots 导出扩展
const info ={
	nane:"why",
	age:18,
	foo:function(){
		console.log("foo函数~")
	}
}
module.exports = info

```
#### 2、require补充
	1、核心文件，如库模块引入 path  fs  。
```js
//举例  模块一般都不带路径。
cosnt path = require("path")
cosnt fs = require("fs")

path.resolve()
path.extname()

fs.readFile()
```
	2、路径文件， ./   ../  / 。 没有后缀则轮询，当找不到当文件夹轮询 。
	当判定，不是路径文件也不是核心文件时，会轮询从绝对路径 -> 相对路径一层层去找。最终找不到 报not found 。
	
#### 3、模块加载细节
	多次引入，会缓存，但只加载一次（用boolean标记）。
	循环引入，加载顺序？
		用到图结构，在遍历中用到算法->深度优先搜索(DFS), 和广度优先搜索(BFS) 。
	CJS规范 加载模块是同步，而浏览器需要异步，否则会导致后续js代码无法执行。所以浏览器不采用CJS规范。webpack 将代码转成异步。早期是原生js、jQuery开发。所以是采用AMD、CMD规范。
	
#### 4、AMD规范 了解 
	Asynchronous Module Definition   (异步模块定义)， 2015年后就废弃了。
```js
//index.html
// data-main  明确告诉浏览器在加载完src后，才加载执行，达到异步。
<script src="./lib/require.js" data-main="./main.js"></script>
```
	库RequireJS 使用
	https://github.com/requirejs/requirejs
```js
//main.js
//引入
require.config({
	baseUrl:'./src',   // baseUrl:'',  这么写  不写baseUrl 属性默认 父目录
	paths:{
		foo:"./foo",  // foo:"./src/foo",    就这么写
		bar:"./bar"   // bar:"./src/bar"
	}
})
// 调用 
require(["foo","bar"],function(foo){
	console.log("main", foo)
})

//bar.js  依赖 foo.js文件
写法1
define(function(){
	require(["foo"],function(foo){
		console.log("bar",foo)
	})
})
简写
define(["foo"],function(foo){
		console.log("bar",foo)
}) 

//foo.js
define(function(){
	const name="why"
	const age =18
	function sum(num1,num2){
		return num1 + num2
	}

	return {
		name,
		age,
		sum
	}
})
```

#### 5、CMD规范 了解
	Common Module Definition 通用模块定义 异步加载，吸收了 CJS优点。
	但CMD 也很少使用。

	SeaJs   https://blog.csdn.net/aliven1/article/details/89190031
```js
//index.html
<script src="./lib/sea.js"></script>
<script>
	seajs.use("./sec/main.js")
</script>

//main.js
	define(function(require, exports, module){
		const foo = require("./foo")
		console.log("foo",foo)
	})
	
//foo.js
	define(function(require, exports, module){
		const name ="foo"
		const age =18
		function sum(num1,num2){
			return num1 +num2
		}

		//exports.name =name
		//exports.age =age

		module.exports ={
			name,
			age,
			sum
		}
	});

```
#### 6、ES Module规范掌握   vue  react  ts  
	没用的知识: node 也开始慢慢从CJS 转为 ES Module 了。
	import  export , 等于替代了 CJS  require  。
	注意: ES Module 会自动采用 严格模式 use strict

	1、会按原生编译，于是遇到import 不识别会报错 ，得加 type="moduel"，让编译以模块进行编译。
	2、模块化加载， 协议前缀不能用file，得用 https 去加载，本地一般会用localhost。
		因为会遇到 cors 报错。
##### 认识基本写法 
**使用**
```js 
//foo.js  导出
const name ="why"
 const age =18
 function foo(){
	console.log("foo")
} 
export{
	name,  //  不能写为 name:name  不是键值对
	age,
	foo
}

//main.js   导入
import {name,age} from "./foo.js"  

//index.html   使用
<script src="./main.js" type="module"></script> 
```
**多种导出写法**
```js
//foo.js
第一种导出写法
export const name ="why"
export const age =18
export function foo(){
	console.log("foo")
}
export class Person { }
第二种导出写法     常用   
 const name ="why"
 const age =18
 function foo(){
	console.log("foo")
}
 class Person { }

export{
	name,  //  不能写为 name:name  不是键值对
	age,
	foo
}
给第二种 起别名  一般不用这种，基本是在导入时候起别名
export{
	name as fName,   
	age as fAge,
	foo as fFoo
}
第三种  default   默认导出  场景：就是用了这个模块的这个内容一定是被用到。且只能有一个
import why from './foo.js'   //这种就是用到了默认导出的内容

const name ="why"
const age =18
function foo(){ }
export {
	name,
	age,
	foo as default
}
简化第三种写法常见这么写   常用   
export default foo
```
**多种导入写法**
```js 
//main.js
第一种导入写法  常用
import {name,age} from "./foo.js"  //不再webpack环境 不能忽略尾缀
第二种导入写法    常用

import {name as fName ,age as fAge} from "./foo.js" 
简化第二种导入写法   常用
import * as foo from "./foo.js" 
console.log(foo.name)  

补充
  1、把 import当函数来用。    了解
import("./foo.js").then(res=>{
	   //res 是{ name, age, foo }
})
  2、 es11 新增  meta属性（值是个url 保存当前文件所在的路径，便于调试）  了解
  console.log(import.meta)
	  

```
**扩展思路：规范一些写法小技巧**
	解读：
		相同目录下的模块文件 都引到 当前目录下的公共出口的文件，
		在外部导入不同的公共出口文件，便于维护 。
```js
//举例
/utils
	format.js    math.js    request.js  index.js

//utils/format.js  
	function timeFormat(){ return "2022-9-22"}
	function priceFormat(){ return 10 }
	export{
		timeFormat,
		priceFormat
	}

//utils/index.js
	自己封装库这么写
		//相当于 简写 improt 再 export
	export { add, sub} from './math.js'
	export { tiemFormat, priceFormat} from './format.js'

	一般第三方库这么写，因为你不知道内部依赖全部拿来。
	export * from './math.js'
	export * from './format.js'

// main.js
	import {add, sub, tiemFormat, priceFormat} from './utils/index.js'
	add(10,20);

//index.html
<script src="./main.js" type="module"></script> 
```
##### 构建过程
	总结： 
		一、也就是import不能包裹写在运行后才会执行的代码内
		二、导入者不能去改变，模块的值。
	静态分析： 不考虑运行后出现的内容，只包含编译时的内容。
	1、构建阶段 ：下载js文件 ，import必须满足静态分析。 
	2、实例化阶段：生成模块环境（绑定变量），开辟空间(初始变量值为undefined), 生成导入环境（绑定开辟空间内的变量）。  让 导出和导入通过空间进行交流。 
	3、求值阶段： 导出模块是可以通过自己的代码修改自己的值，不让导入环境去修改 空间的值。类似只读
##### 奇怪的知识
	CJS 根 ES Module 相互能否调用？
		只有在webpack 情况下 是可以 互相调用。
```js
//CJS
const age =require("")
module.exports ={
	name:"why"
}

//ES Module
import {name} from './abc.js'
export{
	age
}



1、 在浏览器根本不支持CJS。 直接报错
2、 在Node 得分版本
	要么不支持，要么支持但得去配置，新的版本可能支持不用配置。
3、常规开发 基于 webpack
	vue cli  基于webpack ，
	create-react-app 也基于webpack ，
	只有在webpack 情况下 是可以 互相调用。 
```
**动手实现下**
```js
npm init  //先生成 package.js  最后一下y
cnpm  install webpack webpack-cli  // 因为依赖 package.js 记录

npx webpack   //直接根据 index.js 生成 dist 打包文件

1、创建 文件 
//src\foo.js  CJS
const name ="foo"
const age = 18
module.exports = {
    name,
    age
}

//src\index.js   
测试ES Module 用
import { name, age } from './src/foo'
console.log(name, age)
测试CJS 用
cosnt bar = require("./bar")
console.log(bar.name,bar.age)


// index.html  根目录下
<body>
    <script src="./dist/main.js"></script>
</body>

2、为了 用上webpack ，却不搭环境。 直接用npx 来编译 转化代码。能成功说明可以通过webpack实现混用。但有前提：
	1、 文件都放到 src目录下
	2、 用上index.html 
```


	


